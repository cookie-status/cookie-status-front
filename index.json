[
{
	"uri": "https://www.cookiestatus.com/",
	"title": "Cookie Status",
	"tags": [],
	"description": "",
	"content": "Cookie Status The cookiestatus.com website is a knowledge sharing resource for the various tracking protection mechanisms implemented by the major browsers and browser engines.\nFor more information about the service, please consult the FAQ.\nPlease submit suggestions and corrections as issues in the GitHub project. Click here to find your way.\nCurrent status Changes added in the latest release of each browser are indicated with yellow highlight. You can click the icon to be redirected to the respective section in each browser\u0026rsquo;s own \u0026ldquo;Current Status\u0026rdquo; page.\nLast updated: 21 Nov 2024\nChrome storage partitioning added.\nSuggest an edit\nToggle full screen\nBrave Chrome Edge Firefox Safari Mechanism Shields n/a Tracking prevention Enhanced Tracking Protection (ETP) Intelligent Tracking Prevention (ITP) Deployed in 0.55.18 n/a 78.0.276.8 69.0 Safari 11 Latest release Link Link Link Link Link Default protection mode Default Shield settings n/a Balanced Standard ITP enabled Classification of \u0026ldquo;known trackers\u0026rdquo; Multiple filter lists n/a Trust Protection Lists (with engagement and organization mitigation) Disconnect.me Algorithmic Cookies in 3rd party context Restrict access in subresource requests.\nPartitioned access in frame.\nPartitioned storage is cleared when no more first-party documents that use the partition are open, or when the browser is closed. Cookies restricted to a maximum lifetime of 400 days. Access restricted for known trackers. Access restricted for known trackers.\nCookies are partitioned between the site and the third-party. Cookies are not shared across sites.\nAll access restricted, except with Storage Access API.\nCookies in 1st party context For cookies set with document.cookie, expiration set to 7 days.\nOtherwise maximum expiry set to 6 months.\nCookies restricted to a maximum lifetime of 400 days. No restrictions. All storage is purged from known trackers daily, unless the user has interacted with the site in first-party context within the last 45 days. For cookies set with document.cookie, deletion happens after 7 days of browser use without user interaction on the site.\nFor cookies set with document.cookie, expiration set to 24 hours on pages with URL decoration (query parameters or fragments) when referring domain is a known tracker.\nOther browser storage in 3rd party context Partitioned access in frame.\nPartitioned storage is cleared when no more first-party documents that use the partition are open, or when the browser is closed.\nChrome partitions third-party storage. Access restricted for known trackers.\nNo restrictions for other domains.\nlocalStorage and IndexedDB restricted for known trackers.\nsessionStorage is not restricted.\nStorage is partitioned between the site and the third-party. Storage is not shared across sites.\nlocalStorage is partitioned and reset between application launches.\nIndexedDB is restricted.\nsessionStorage is partitioned.\nOther browser storage in 1st party context No restrictions. No restrictions. No restrictions. All storage is purged from known trackers daily, unless the user has interacted with the site in first-party context within the last 45 days. All script-writable storage is deleted after 7 days of browser use without interaction (click, tap, text input) with the site. CNAME cloaking Brave blocks any network requests where either the requested URL or that URL\u0026rsquo;s CNAME record matches any rules in Brave\u0026rsquo;s blocklists. No restrictions. No restrictions. No restrictions. Expiration of cookies set with Set-Cookie HTTP response headers is 7 days at most, if the response originates from a subdomain that has a CNAME alias to a cross-site origin, or if the subdomain is configured with A/AAAA records where the first half of the IP address does not match the first half of the IP address of the website the user is currently browsing. Referrer strict-origin-when-cross-origin or stricter referrer policy in subresource requests and cross-site navigational requests.\nSame-site navigation preserves the referrer.\nDefault browser policy (strict-origin-when-cross-origin) Default browser policy (strict-origin-when-cross-origin) Default browser policy (strict-origin-when-cross-origin or stricter)\nIf the referring URL has a tracking parameter (e.g. fbclid), document.referrer string is truncated to eTLD+1.\nDowngrade cross-site document.referrer to origin.\nDowngrade all cross-site request headers to origin.\nFor referrers that are known trackers, where the referring page also has URL decoration (query parameters or fragments), document.referrer is downgraded to eTLD+1.\nDefault browser policy (strict-origin-when-cross-origin)\nOther Remove known tracking parameters (fbclid, gclid, msclkid, mc_eid, and others) from URL query strings.\nRandomize HTML canvas fingerprints by first-party domain.\nFreeze Mac OS X version to 10_15_7 in the User Agent string.\nFreeze Mac OS X version to 10_15_7 in the User Agent string.\nFreeze Mac OS X version to 10_15_7 in the User Agent string.\nAutomatically block requests to tracking domains that are also listed in the Fingerprinting category of the Disconnect.me list.\nFreeze Mac OS X version to 10_15 in the User Agent string.\nDetect delays in bounce trackers and treat them as regular bounces.\nExtend WebKit\u0026rsquo;s tracking protections to all browsers running on iOS 14 and newer. These protections can only be disabled by the user.\nPurge all site data from classified domains if no user interaction (or Storage Access API grant) in first-party context has been recorded in the last 30 days.\nFreeze Mac OS X version to 10_15_7 in the User Agent string.\nSafari hides the user\u0026rsquo;s IP address in requests sent to known trackers.\nFAQ 1. Why does this resource exist? Web browsers are going through fairly momentous shifts in order to better respond to the increasing number of data breaches and cases of data misuse by third parties.\nUnfortunately, each browser (and the underlying browser engine) seems to have their own interpretation of how to best tackle the problem, which leads to a diverse set of features across the browser landscape.\nWhat\u0026rsquo;s worse, the information about how these tracking protection mechanisms are deployed is all over the place: in release notes, in developer documentation, in Twitter threads, in working groups, in feature drafts, in bug patches, etc.\nThe purpose of the Cookie Status resource is to (attempt to) collect this information in one place for easy access and perusal.\nThere is no commercial agenda behind this project. In fact, there is no agenda other than knowledge transfer.\n2. Why only these browsers? Just to kick things off. Hopefully the open-source nature of this project will invite others to contribute details about browsers that are doing significant work with regard to user privacy.\n3. What cookies / browser storage does Cookie Status set and why? Cookie Status doesn\u0026rsquo;t use browser cookies, localStorage, or IndexedDB.\nsessionStorage is used to add some functionality to navigation (marking visited pages, highlighting search terms).\nNothing in browser storage is sent to any third parties at any time.\nIf you see anything contrary to the above, please raise an issue about this.\n"
},
{
	"uri": "https://www.cookiestatus.com/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction General introduction to tracking prevention / protection, what it is, and what its various implications are.\n"
},
{
	"uri": "https://www.cookiestatus.com/brave/",
	"title": "Brave",
	"tags": [],
	"description": "",
	"content": "Current status Detail Description Mechanism Shields Originally deployed in 0.55.18 Latest update deployed in v1.30.86 Latest update includes No longer block requests to filtered origins if the requests are same-site with the site the user is browsing. User controls Site-specific and global controls for: Cross-site tracker blockingAutomatic connection upgrade to HTTPSScript blockingCookie blockingDevice recognition blocking Brave Shields default settings Classification of \u0026ldquo;known trackers\u0026rdquo; Brave classifies tracking domains using input from multiple lists:\nEasyList EasyPrivacy uBlock Origin Unbreak uBlock Origin Filters uBlock Origin Filters - Privacy Brave\u0026rsquo;s own Unbreak list Brave\u0026rsquo;s own cryptominer list Brave\u0026rsquo;s fork of Disconnect.me Brave matches each outgoing request from the web browser against these lists (using various methods for achieving optimized performance), and if a match is made, the request is blocked.\nNote! If the resource that should be blocked is same-site to the site the user is browsing, the request will not be blocked. Thus if the user is browsing www.domain.com and the browser sends a request to blocked-tracker.domain.com (which is in Brave\u0026rsquo;s filter lists), the request will not be blocked.\nExample: The user visits a site that tries to load the Google Analytics JavaScript library from https://www.google-analytics.com/analytics.js. This URL (and the entire domain, in fact), is listed in the EasyPrivacy list. Thus Brave blocks the request, preventing the browser from downloading the library and executing the Google Analytics tracking code in the web browser.\nBy blocking requests upstream, it means that if the request initiated a resource download (such as a JavaScript library), this resource is never downloaded and thus the code is not executed in the user\u0026rsquo;s browser. If the request initiated a pixel call (such as a GET for an image), it means the pixel call will be aborted before it is received by the endpoint.\nThird-party cookies All third-party cookies are blocked by default in subresource requests (e.g. CDN loads, pixel pings).\nBrave uses \u0026#34;cross-site\u0026#34; interchangeably with \u0026#34;third-party\u0026#34; in this case In frames (e.g. \u0026lt;iframe\u0026gt;), access is partitioned and set to site-length expiration.\nPartitioned access means that the document.cookie API will work in a cross-site \u0026lt;iframe\u0026gt;, but the storage will be unique between the site embedding the frame and the frame itself. Another site embedding the same frame would have a different storage profile.\nSite-length expiration means that as soon as the last page of the site embedding the cross-site frame is closed, the partitioned storage is cleared. This is different to how e.g. Safari works, where the storage is cleared only upon the browser being closed (this clears the storage also in Brave).\nFirst-party cookies For cookies set with JavaScript\u0026rsquo;s document.cookie, expiration is set to a maximum of 7 days.\nExample: The user visits a page that is running an A/B testing tool which stores the experiment details into a cookie named __exp. This cookie is set with JavaScript. Even though setting the cookie works, and the user is assigned to an experiment group successfully, if the user takes more than 7 days to revisit the site, the cookie will have been expired and the user would potentially get assigned to a new, different group upon their next visit.\nFor cookies set with the Set-Cookie HTTP response header, expiration is set to a maximum of 6 months.\nOther third-party storage Partitioned and site-length expiration for localStorage and sessionStorage APIs (see Third-party cookies for more information).\nNote that since Brave blocks resources found in their classification lists, it has the downstream effect of blocking storage access from these vendors who now can\u0026rsquo;t execute their JavaScript in the user\u0026rsquo;s browser or respond to the blocked HTTP requests.\nOther first-party storage No restrictions.\nNote that since Brave blocks resources found in their classification lists, it has the downstream effect of blocking storage access from these vendors who now can\u0026rsquo;t execute their JavaScript in the user\u0026rsquo;s browser, or respond to the blocked HTTP requests.\nCNAME cloaking Brave Shields blocks network requests to domains in Brave\u0026rsquo;s blocklists. With version 1.17.73, Brave now also resolves the DNS of any given domain and identifies if there are CNAME records pointing to domains that are in the blocklists, and blocks these as a result, too.\nExample: The web page sends a pixel request to https://measure.example. This domain is not in Brave\u0026rsquo;s blocklist, so Brave would normally allow the network request to complete. However, measure.example is a CNAME record which actually points to track.everything, which is in Brave\u0026rsquo;s blocklist. As the domain the CNAME points to is in Brave\u0026rsquo;s blocklist, Brave blocks the initial request to https://measure.example as a consequence.\nReferrer For cross-origin subresource and navigational HTTP requests, Brave defaults to the strict-origin-when-cross-origin Referrer Policy. Brave prevents the policy from ever being more relaxed than this, so even if a policy of e.g. unsafe-url is used, cross-origin requests would still have the referrer set to just the origin of the referring page.\nExample: When clicking a link from https://domain.com/page to https://anotherdomain.com/another-page/, the referer header is set to https://domain.com. Similarly, the document.referrer will be set to https://domain.com once the user lands on anotherdomain.com.\nFor same-site requests (both navigational and non-navigational), referrer has normal behavior.\nOther Brave removes known tracker identifier parameters from URL strings. On top-level navigation (e.g. landing on a page with such parameters in the URL), the parameters are stripped out in a 307 internal redirect. On non-navigational HTTP requests, the parameter is stripped from the request URL.\nHere is the list of parameters that are stripped:\n__hssc (HubSpot) __hstc (HubSpot) __hsfp (HubSpot) __s (Drip) _hsenc (HubSpot) _openstat (OpenStat) dclid (Google) fbclid (Facebook) gbraid (Google) gclid (Google) hsCtaTracking (HubSpot) igshid (Instagram) mc_eid (Mailchimp) ml_subscriber (MailerLite) ml_subscriber_hash (MailerLite) msclkid (Microsoft) oly_anon_id (Olytics) oly_enc_id (Olytics) rb_clickid s_cid (Adobe) twclid (Twitter) vero_conv (Vero) vero_id (Vero) wbraid (Google) wickedid (Wicked) yclid (Yandex/Yahoo) Example: If the user types https://www.domain.com/?fbclid=1.2.3.4 in the omnibox and presses enter, Brave strips the parameter in an internal redirect. Similarly, if the browser makes a request to https://www.domain.com/tracking-pixel.gif?mc_eid=23456, Brave strips the parameter out of the request before it hits the target server.\nBrave has lots of initiatives for neutralizing fingerprinting surfaces, with features such as randomized HTML canvas fingerprints preferred over just removing or clearing the fingerprint surfaces.\nOn macOS Brave, the version number in the User Agent string is frozen to 10_15_7 to fix compatibility issues with upgrading to macOS version 11+ (Big Sur). This has obvious privacy implications as well, as the platform version is no longer useful for fingerprinting purposes.\nSample User Agent string when running Brave 1.24.85 on macOS 11.3.1: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\u0026quot;\n´\n"
},
{
	"uri": "https://www.cookiestatus.com/introduction/tracking-protection/",
	"title": "Tracking protection",
	"tags": [],
	"description": "",
	"content": "Tracking protection, and similar measures, seek to protect the user from covert data collection and exploitation by scripts and applications created for such purposes.\nIn short, tracking protection, tracking prevention, anti-tracking, cookie blocking, content blocking, etc. are designed to:\nIdentify and classify domains that utilize and distribute tracking mechanisms obstructive to (browsers\u0026rsquo; interpretation of) web user privacy. Restrict storage access in third-party context for such scripts so that the trackers cannot build cross-site profiles of web users. In some cases, restrict storage access in first-party context where it\u0026rsquo;s likely that it could be exploited for cross-site tracking purposes. In this introductory chapter, we\u0026rsquo;ll gloss over some of the key terminology regarding tracking protection. You are then advised to visit the other pages of Cookie Status for more details.\nCookies First-party and third-party context Cross-site tracking Storage access restriction Cookies Browser cookies are key-value pairs (e.g. id=abcd1234) of information stored on the user\u0026rsquo;s computer. Websites set them in order to persist information from one page to the next. This is because the web is effectively stateless - only a very limited set of information is shared from one page to the next. By writing information into browser storage, that information persists even if the pages the user navigates from are unloaded and their storage purged.\nTypical use cases for cookies include persisting a shopping cart from one page to the next on an ecommerce site, storing details about user\u0026rsquo;s login status, and for setting an identifier for the user, so that their visits can be recognized in an analytics tool as originating from the same browser.\nWebsites can write cookies on the user\u0026rsquo;s computer, and they can read cookies from the user\u0026rsquo;s computer. How effective this is depends on whether the user\u0026rsquo;s browser allows cookie access in third-party context, and whether cookies in first-party context have restrictions as well.\nFirst-party cookies set on the current domain and on the eTLD\u0026#43;1 Reading cookies Cookies can be read and written in two ways: with HTTP headers and with JavaScript.\nThe first method relates to the browser requesting resources from a web address. This is done via an HTTP request.\nWhen the browser requests a resource from a web address, that request will include a cookie header, which includes all the cookies written on the target domain and all the domains in its domain hierarchy up to the eTLD+1.\neTLD+1 means effective top-level domain plus one part. The eTLD is the same thing as the Public Suffix. For a domain like blog.ecommerce.cookiestatus.co.uk, the eTLD would be .co.uk, and the eTLD+1 would be cookiestatus.co.uk. For a domain such as cookiestatus.github.io, the eTLD would be github.io and the eTLD+1 would be cookiestatus.github.io.\nThis is what a sample HTTP request would look like with the cookie header in place:\nSample cookie header with all cookies available on the target domain The cookie header must respect the cookie settings in the browser. If the browser blocks third-party cookies, the cookie header is only included for requests in first-party context. Similarly, if the browser blocks all cookies, the cookie header will not be included in any requests.\nBecause the cookie header is part of the HTTP request, it means that the web server hosting the resource will be able to read this header and use this information at will.\nThe browser can read cookies with JavaScript as well.\nWhile the user is browsing a website, that website can use JavaScript to read the cookies written on the current domain and all the domains up to the eTLD+1.\nconst cookies = document.cookie; console.log(cookies); // userId=abcd1234; logged-in=true If document.cookie is invoked in a third-party context, such as an \u0026lt;iframe\u0026gt; element embedding content from a third-party source, the string will be populated only if the web browser allows third-party cookies.\nSince the cookies are readily available for any JavaScript running on the page, a malicious vendor with a script running on the site could utilize the API to read and process the cookies stored on the user\u0026rsquo;s company.\nWriting cookies Similar to reading cookies, the HTTP protocol can be used to write cookies as well. The web server can return with an HTTP response including the Set-Cookie header.\nThis header is an instruction to the browser to write the included cookie(s) on the domain specified in the header.\nSample Set-Cookie header with instructions on which domain to write the cookie Using JavaScript, the document.cookie API can be used to write cookies, too.\nWhile on the www.cookiestatus.com domain, the following command would write a userId cookie on cookiestatus.com.\ndocument.cookie = \u0026#39;userId=abcd1234;domain=cookiestatus.com;path=/\u0026#39;; Web servers and JavaScript libraries can thus write cookies on the eTLD+1, which means they become automatically available to all subdomains of that host. Thus a script running on blog.ecommerce.cookiestatus.com can check if the user has an identifier written on cookiestatus.com, and utilize that. This can be abused for cross-site tracking purposes.\nFirst-party and third-party context It\u0026rsquo;s common in the parlance of the web to talk about first-party cookies and third-party cookies. This is a bit of a misnomer. Cookies are pieces of information that are stored on the user\u0026rsquo;s computer. There is no distinction between first-party and third-party in how these cookies are classified and stored on the computer.\nWhat matters is the context of the access.\nNevertheless, to align with other discussions around the same topic, Cookie Status will use first-party cookie and third-party cookie for clarity\u0026rsquo;s sake.\nFirst-party context means that the operation happens between domains within the same site, í.e. domains that share the eTLD+1. Third-party context means that the operation happens cross-site, i.e. between domains that do not share the eTLD+1.\nHere are some examples. Consider the user to be on the domain www.cookiestatus.com.\nScenario Type of context eTLD+1 Details The browser requests an image from images.cookiestatus.com. First-party context cookiestatus.com The cookie header includes all cookies written on images.cookiestatus.com and cookiestatus.com. The Set-Cookie header can write a cookie on *.cookiestatus.com. The browser loads a JavaScript file from cdn.vendor.com. Third-party context cookiestatus.com vs. vendor.com The cookie header includes all cookies written on cdn.vendor.com and vendor.com. The Set-Cookie header can write a cookie on *.vendor.com. The browser runs document.cookie on the page in the top frame (the main window). First-party context cookiestatus.com The command can be used to read and write cookies on www.cookiestatus.com and cookiestatus.com. The browser loads a page from booking.vendor.com in an \u0026lt;iframe\u0026gt; and runs document.cookie on that page. Third-party context vendor.com The command can be used to read and write cookies on booking.vendor.com and vendor.com. In the first-party context scenarios above, the cookie read/write operations will work unless the browser blocks all cookies or has cookiestatus.com in a blacklist.\nIn the third-party context scenarios, the cookie operations will work unless the browser blocks all third-party cookies, has vendor.com in the blacklist, or the possible tracking protection mechanisms have deemed vendor.com to be a tracking domain.\nCookie access in a first-party context is rarely blocked, because many features of modern websites rely on state management in the browser (using cookies or other browser storage). However, some vendors are repurposing first-party cookies for cross-site tracking, which has led to browsers (especially Safari) to place restrictions on first-party storage as well.\nAccessing cookies in a third-party context is necessary for some benign features of the web, such as persisting user authentication across the domains of an organization (SSO), or for passing information about user\u0026rsquo;s marketing consent from one part of the organization to another.\nHowever, cookie access in a third-party context can be abused as well, because it can be used for cross-site tracking without the user\u0026rsquo;s consent or awareness.\nCross-site tracking A common thread in the rhetoric is that browsers want to quench cross-site tracking. Here\u0026rsquo;s how Safari describes it:\nImagine a user who first browses example-products.com for a new gadget and later browses example-recipies.com for dinner ideas. If both these sites load resources from example-tracker.com and example-tracker.com has a cookie stored in the user’s browser, the owner of example-tracker.com has the ability to know that the user visited both the product website and the recipe website, what they did on those sites, what kind of web browser was used, et cetera. This is what’s called cross-site tracking and the cookie used by example-tracker.com is called a third-party cookie. In our testing we found popular websites with over 70 such trackers, all silently collecting data on users.\nIn essence, cross-site tracking utilizes centralized tracking domains for scripts to communicate with from the sites the user actually visits. These tracking domains leverage third parties\u0026rsquo; access to browser storage (mainly cookies) to build profiles of all the sites the user has visited.\nCross-site tracking To continue the examples from the previous chapters, when the user\u0026rsquo;s browser makes a request for image.imagestore.com while on the blog.ecommerce.cookiestatus.com website, the endpoint at image.imagestore.com will now know that the request originated from blog.ecommerce.cookiestatus.com, as this is included in the origin and referer [sic] headers.\nThus the endpoint at image.imagestore.com could now check if the user has an identifier cookie set on that domain, and they can augment the profile for that identifier with knowledge that the user has visited blog.ecommerce.cookiestatus.com.\nIf the user then visits another page on the internet that also communicates with image.imagestore.com, then that endpoint will be privy to yet another origin, and they can keep building the profile.\nThis is the essence of cross-site tracking - using a consolidated and centralized store (e.g. a cookie) to collect information from different domains.\nStorage access restriction Browsers\u0026rsquo; main weapon against cross-site tracking is restricting storage access. Because there are valid reasons for cross-site tracking (persisting user authentication, shopping baskets, consent status), tracking protection methods restrict storage access for third parties that have been identified and classified as compromising user privacy.\nAll major browsers now partition storage in some way. Partitioning means that storage access isn\u0026rsquo;t necessarily blocked, but it is keyed between two cross-site origins.\nFor example, site b.example, when embedded on a.example, would have access to its cookies and other storage mechanisms, but these mechanisms would be unique to the combination of b.example–a.example. If another site, such as c.example, were to embed content from b.example, they would have a new, unique partition for storage which would be different from what was available when accessed via a.example.\nList-based protection Mozilla Firefox, for example, describes their own effort like this:\nIn order to help give users the private web browsing experience they expect and deserve, Firefox will strip cookies and block storage access from third-party tracking content, based on lists of tracking domains by Disconnect.\nThis approach of comparing the third-party domains against a curated list is utilized also by Microsoft Edge. Here\u0026rsquo;s how they introduce Edge\u0026rsquo;s tracking prevention:\nWe’ve added a new component to Microsoft Edge, Trust Protection Lists**,** that contains the latest information on which organizations may be trying to track users on the web. This component allows us to be flexible with where we source details on what a tracker is and when we deliver updated lists to our users.\nThe Brave browser, similarly, pulls in tracking domains from multiple sources. Notably, Brave combines prescribed lists (from e.g. EasyList and uBlock Origin) with a more dynamic list based on crawl data (PageGraph).\nWith list-based protection, the browser maintains a list of domains against which each outgoing HTTP request from the site is pattern-matched. If there is a match between the request target and one of the domains in these lists, the request is blocked.\nThis means that browsers can block both downloading script resources and HTTP requests to tracking endpoints (e.g. image pixels).\nBy blocking the script download, browsers don\u0026rsquo;t need to worry about further storage access restrictions, because the JavaScript from the vendor was never loaded and thus can\u0026rsquo;t abuse the browser storage on the user\u0026rsquo;s company.\nBy blocking the pixel and other HTTP endpoints, browsers ensure that in cases where the site is loading the JavaScript from a non-blocked source, the script will not be able to communicate with its endpoint.\nThe biggest problems with list-based protection are:\nThe performance overhead of pattern-matching each HTTP request against an ever-growing list of domains (something that these browsers are actively optimizing). Reaction lag to new trackers and domains that need to be blacklisted. Difficulty in handling locally cached and/or proxied requests. Harm to other functionality (besides tracking) that these blocked libraries provide. Algorithmic protection The Safari browser has opted for a different tact. Instead of a binary approach (blocked vs. not blocked) and a set list of domains, Safari\u0026rsquo;s Intelligent Tracking Prevention uses multiple methods to restrict the storage access for third parties that are algorithmically classified as having cross-site tracking capabilities. Here\u0026rsquo;s how they describe the classification process:\nA machine learning model is used to classify which top privately-controlled domains have the ability to track the user cross-site, based on the collected statistics. Out of the various statistics collected, three vectors turned out to have strong signal for classification based on current tracking practices: subresource under number of unique domains, sub frame under number of unique domains, and number of unique domains redirected to. All data collection and classification happens on-device.\nNote that in early 2020, WebKit\u0026rsquo;s tracking protections were extended to block all third-party cookies without exception. Thus the algorithmic classification no longer applies to how third-party storage is accessed, but it is still used for other tracking-related protections (such as downgrading the referrer).\nHowever, Safari\u0026rsquo;s approach is binary in a sense - you can either enable all cross-site tracking or none.\nSafari privacy settings Cliqz has a similar tact. This is explained in detail in this research paper, and in this blog post. Basically, they combine local and global evaluation of the data passed to and from the web browser to establish heuristical models for identifying potential tracker connections.\nCliqz\u0026rsquo; approach is two-fold. First, they purge identifiers from the HTTP requests that could be misused for tracking. Second, they block cookie access in third-party context, unless the user interacts with the third-party domain (e.g. in a widget).\nA global safe set is compiled from the actions Cliqz\u0026rsquo; anti-tracking mechanism takes on each individual browser, and this global research data is used to fine-tune the local behavior of Cliqz\u0026rsquo; tracking protections.\nThe algorithmic approach is effective because it identifies potential tracking domains dynamically and without using a centralized list. This means that there\u0026rsquo;s less overhead in pattern-matching the HTTP requests as the list of domains for the browser would only include those the browser has actually communicated with.\nThe algorithm also ensures that locally hosted tracking domains and reverse proxies would also be under scrutiny (unless served in a same-site context).\nThe main problems with this approach are:\nFalse positives, where the algorithm classifies domains that serve no cross-site tracking purpose, or purges identifiers that are not used for tracking. There is also some reaction lag, because the algorithm would require enough data to classify each new domain. It\u0026rsquo;s thus possible some communication with a tracking domain would be permitted before access is restricted. Lack of predictability, which is not necessarily a problem or a bad thing, but a list-based approach allows for community oversight of the domains that have been blacklisted. Note that for false positives blocking access to cross-origin storage, ITP offers the Storage Access API. However, there is no provision in ITP to remove a domain from the list of classified domains, which means that first-party protections would still apply.\n"
},
{
	"uri": "https://www.cookiestatus.com/introduction/summary-of-exploits/",
	"title": "Summary of exploits",
	"tags": [],
	"description": "",
	"content": "There are a number of ways in which data exploitation is attempted by malicious trackers. On this page, these will be listed superficially.\nThe problem is that all these methods also serve valid and benign use cases, which means that when browsers seek to prevent these, they also end up preventing non-malicious and non-exploitative use of browser storage.\nAnd this is the nature of the beast. The very same APIs and methodologies that are used, for example, to improve the user experience of the site are simultaneously being repurposed by third parties for data collection and manipulation.\nSee the chapter on Impact for more details on how countering these exploits is impacting other, potentially benign use cases.\nThe exploits listed here are:\nCookies in third-party context Link decoration Referrer decoration Fingerprinting CNAME records Cookies in third-party context Leveraging browser cookies in third-party context (so-called third-party cookies) is the age-old way how advertising technology vendors build audiences for improving their targeting mechanisms.\nBy observing the user\u0026rsquo;s browsing behavior across the web, ad tech vendors can build robust profiles and deduce the user\u0026rsquo;s interest and affinity groups based on the sites they visit. Naturally, the robustness of this profiling depends on how many sites are included in this network, which is why large technology companies have the upper hand due to an extended reach and an established ecosystem.\nThese vendors are able to build these audiences if the user\u0026rsquo;s browser does not block access to third-party cookies.\nFor example, if you browse a site that has a Google DoubleClick pixel firing, or has Google Analytics set up so that the site communicates with DoubleClick servers, you might see the following network request:\nRequest to DoubleClick on the first site It\u0026rsquo;s a request to DoubleClick\u0026rsquo;s domain (the request URL is something like https://1234567.fls.doubleclick.net/activityi...). As you can see in the cookie header, the user\u0026rsquo;s browser has cookies set on this domain, and one of these cookies is named DSID with a long, hashed identifier string.\nNow, visit another, completely different site that also sends requests to DoubleClick servers and observe the network requests:\nRequest to DoubleClick on the second site It\u0026rsquo;s another request to DoubleClick. This time the subdomain might be different, e.g. https://98765432.fls.doubleclick.net/activityi..., but since the cookie is written on the eTLD+1, you can see the result in the screenshot:\nThe DSID value is exactly the same as on the other website.\nThus, when you visit these two sites without restricting access to third-party cookies, DoubleClick will know that your particular DSID is now associated with visits to these two websites.\nThis type of covert tracking is called cross-site tracking, and it can be used by vendors to build their own profiles. However, it can also be abused by data management platforms (DMPs) that participate in cookie matching between multiple vendors to build an even larger user database.\nUnfortunately, this very same method is used for benign scenarios, such as persisting user authentication across different websites of the same organization.\nIf cookies in third-party context are blocked by the browser, then there are other means to achieve the same type of profiling, such as by repurposing the first-party context.\nLink decoration When vendors find out that their attempts to leverage cookies in third-party context are thwarted, they will repurpose the first-party context to continue tracking users across websites.\nFor example, if the vendor has a first-party ecosystem (such as a social media platform or a suite of products behind a shared authentication) coupled with an ad tech network (or they participate in cookie matching), they are well positioned to hijack first-party storage to build a profile of visitors.\nRepurposing first-party context is more effective if the vendor has a first-party service to which the user can log in. Services that only exist in third-party contexts (such as display networks) are most vulnerable to tracking protection measures.\nWhen the user is logged in to the vendor platform, they have a unique identifier that the vendor can use to recognize them. There is nothing exceptional about this - it\u0026rsquo;s exactly how any login would authenticate a user.\nHowever, what the vendor can then do is decorate every single link leading out of the platform with a hash containing the user\u0026rsquo;s unique identifier. Thus a link like https://www.cookiestatus.com/ now becomes https://www.cookiestatus.com/?vendorid=ABCDefgh1234IJKL5678mnop.\nWhen the user follows the link, all it takes is for any one of the vendor\u0026rsquo;s JavaScript libraries (or a collaborating partner\u0026rsquo;s JavaScript libraries) to run on the site for the ID to be written into first-party storage as a cookie, thus being impervious to third-party context blocking, and to be sent with e.g. remarketing or conversion pixel requests back to the vendor.\nURL decoration by vendors This way the vendor will know that the logged-in user not only followed the link, because they can track clicks on the link, but they\u0026rsquo;ll also know what they did on the target site due to the JavaScript firing on that site and communicating this information back to the vendor.\nLink decoration is not always reliable. Sites might introduce redirects that strip parameters from the URL (or break if non-whitelisted parameters are added), and tracking protection mechanisms (especially ITP) can be used to handicap first-party storage when link decoration is involved. Thus vendor platforms can also decorate the referrer string to avoid having their identifiers paraded in the URL of the target site.\nReferrer decoration Referrer decoration works exactly the same as link decoration, except instead of decorating the URL to which the user is navigated, the service creates an intermediate page through which the user is redirected.\nThis page would have the user identifier in its URL.\nBy doing so, the document.referrer string (and the referer HTTP header) would include the identifier, and the vendor\u0026rsquo;s JavaScript libraries could, again, use this information to relay the user\u0026rsquo;s navigation patterns back to the vendor.\nReferrer decoration is resilient to things like redirects stripping out query parameters of the target URL, and due to browsers\u0026rsquo; referrer policies, it is not a very reliable way to pass information from one site to the other.\nBrowsers are taking a stronger stance against leaking information in referrers, adopting policies like strict-origin-when-cross-origin by default (this would strip referrer strings to their hostnames when the request is not same-site). Safari\u0026rsquo;s intelligent tracking prevention is going even further, stripping document.referrer to eTLD+1 (so https://my.site.com/?id=12345 would become https://site.com) in cross-site tracking scenarios.\nIf the vendor does not have a strong enough first-party ecosystem to decorate links or referrers with user identifiers, they can attempt cross-site tracking through browser and device fingerprinting.\nFingerprinting Fingerprinting is a methodology where user\u0026rsquo;s browser and device settings, at least those that are exposed to JavaScript APIs and HTTP headers, are used to build a digital fingerprint of the user\u0026rsquo;s browser instance.\nThe logic is that since the user is very likely to use the same browser and device when browsing the web, this fingerprint can be utilized on different websites to uniquely identify the user.\nIndividual flags in the fingerprint (such as browser name, version, timezone) are not capable of recognizing a user, but the more flags that are added the higher the entropy, and the more likely the user can be uniquely identified by the combination of these browser settings.\nFingerprint APIs that utilize hardware configurations, such as Canvas, Web Audio, and WebGL are most robust, especially when used together. These are also the APIs most targeted by fingerprinting prevention measures.\nYou can use the AmIUnique service to check how unique your current fingerprint is.\nSample AmIUnique result Browsers are coming down strongly on fingerprinting. Chrome introduced the privacy budget as a concept they\u0026rsquo;re looking into, Safari is actively reducing potential fingerprinting surfaces, Firefox is blocking scripts that distribute fingerprinting tools (as is Edge), and then there are browsers like Brave where fingerprinting protections are front-and-center of development.\nCNAME records Sometimes the web browser is just too unreliable for vendors to leverage efficiently for their cross-site tracking purposes.\nAll the exploits listed above have native preventions in place in many browsers, and there are also browser extensions that help with tracking protection as well.\nThis is why some vendors recommend site owners to set up new domains in their own domain namespace (thus becoming part of first-party context), but instead of pointing to a server owned by the site, the domains would be mapped to vendor servers.\nA simple way to accomplish this is with a CNAME (canonical name) DNS record. The CNAME record maps a hostname such as tracker.domain.com to a canonical domain name (e.g. abcd123.tracking-vendor.com), provided and owned by the vendor.\nThe website can then make requests to tracker.domain.com, and the request would be transferred through the CNAME chain all the way to the web server owned by the vendor. Thus the vendor would have access to all cookies written on tracker.domain.com and domain.com.\nCNAME record in DNS settings It doesn\u0026rsquo;t solve cross-site tracking by itself, because the endpoint would only have access to cookies written on domain.com (and not, e.g. vendor.com), but by sending the identifiers from link decoration or referrer decoration, or by fingerprinting the browser, the vendor can continue profiling the user with little risk of getting the domain blacklisted.\nThere are serious security issues involved with surrendering subdomains to third parties, so site owners should consistently and carefully audit any traffic passing through their domains.\nBrowsers can\u0026rsquo;t natively resolve CNAME records for a given hostname (apart from Firefox, to some extent). However, identifying known trackers in CNAME records is getting more attention, and it is likely that browsers will introduce the necessary APIs so that they can block or restrict this type of data access as well.\n"
},
{
	"uri": "https://www.cookiestatus.com/introduction/impact/",
	"title": "Impact",
	"tags": [],
	"description": "",
	"content": "The tracking protection measures taken by browsers have a widespread impact on a variety of things, including web development, advertising and marketing technologies, digital analytics, and user experience optimization.\nWebsites use cookies and other browser storage for a plethora of things, such as persisting login state, preserving items in a shopping cart, and for presenting tailored experiences in a first-party context, based on what the user has done while visiting the site.\nSimilarly, digital analytics uses anonymous/pseudonymous identifiers stored in first-party cookies to identify the hits collected across a span of time as coming from the same browser instance.\nThe methods used for cross-site tracking are often indistinguishable from those harnessed for more mundane purposes. Thus tracking protection measures tend to disrupt regular functionality of the web while seeking to eradicate malicious tracking.\nWeb development Websites regularly utilize cookies in both first-party and third-party context for persisting user authentication, for storing marketing consent, for identifying active sessions, and for operating with \u0026lt;iframe\u0026gt; elements that embed content from other sites.\nCookies in third-party context Because browsers like Edge and Firefox use lists (Trust Protection Lists and Disconnect.me, respectively) to collect information about known trackers, it\u0026rsquo;s unlikely that any regular website would get their domain blacklisted. It would require that domain to participate in a tracking scheme, and for some public push to get the domain classified as a tracking domain.\nBeginning of the Disconnect.me entity list On browsers like these, using their default tracking protection settings, websites could still continue to operate efficiently with third-party cookies.\nBrowsers like Safari and Brave block all third-party cookie access. This means that both benign (e.g. SSO flows) and cross-site tracking scenarios are neutered. Safari offers the Storage Access API as a way for sites to establish consent from the browser user for allowing access to third-party storage.\nBecause of this, websites that require third-party cookies should utilize the Storage Access API to get user\u0026rsquo;s consent to access first-party storage for a classified domain.\nRequesting storage access via the API Cookies in first-party context With browsers such as Chrome, Edge, and Firefox, the first-party context is unimpacted when it comes to tracking protection.\nWith Safari, script-writable storage is impacted by Intelligent Tracking Prevention.\nCookies set with JavaScript (document.cookie) have a maximum expiration of 7 days or 24 hours, depending on where the user navigated from to the current page. Other script-writable storage is restricted to 7 days in similar navigational scenarios. This means that websites should avoid setting cookies with JavaScript where possible, and they should similarly avoid leveraging other script-writable storage for long-term persistence.\nCookies should never be used to store or send confidential information. They are inherently insecure, regardless of what flags are set when they are created.\nWebsites should set business-critical cookies with the Set-Cookie header using the SameSite and Secure flags. If the cookie does not need to be accessed by JavaScript, then the HttpOnly flag should be set as well.\nBy setting the cookie in an HTTP response, it is unimpacted by Intelligent Tracking Prevention\u0026rsquo;s restrictions on first-party storage.\nReferrer downgrade With cross-origin requests, browsers are moving to a stricter default policy of stripping the referrer to its origin, thus removing all path, query, and fragment identifiers from it.\nSafari is taking an even stricter stance, stripping all cross-origin referrers to their origin, but also downgrading referrers to eTLD+1 (so www.mysite.com/path becomes mysite.com) when the navigation source is a classified domain with URL decoration.\nNavigation from www.gtmtools.com (a classified domain) becomes a referrer string that\u0026#39;s stripped to eTLD\u0026#43;1 Because of the unreliability of the referrer, websites should avoid placing too much importance on interpreting what is stored in the referrer string, especially when using JavaScript\u0026rsquo;s document.referrer.\nThe Brave browser has adopted an even stricter stance, where they opt to spoof the referrer on cross-origin requests:\nSecond, Brave modifies the referrer header when making cross origin requests. Brave \u0026ldquo;lies\u0026rdquo; on these requests, and says the request was being issued from the same domain being requested, instead of the true, cross-domain origin.\nAdvertising and marketing technologies For AdTech vendors relying on storage access in third-party context, there are some tough times ahead. With Safari, Edge, and Firefox blocking third-party cookies for known trackers, it doesn\u0026rsquo;t take much for a vendor to be blocklisted or classified as a tracker, leading to severely handicapped tracking capabilities.\nVendors are becoming more outspoken in their attempts to work around browser restrictions. Some companies are approaching site owners with instructions on how to setup CNAME redirects and reverse proxies to avoid ad blockers from preventing data collection. The ethical nature of such approaches is questionable at best.\nEven advertising that takes place in a first-party context (such as Google\u0026rsquo;s search ads) is being hampered by browsers\u0026rsquo; efforts. Safari\u0026rsquo;s Intelligent Tracking Prevention reduces the maximum expiration for cookies and browser storage if the user navigates to the site from an ad click, and if the source of the navigation is a known tracker (e.g. Facebook or Google). Thus the site\u0026rsquo;s capability to attribute a conversion taking place in the near future to the ad click is compromised.\nIn short, for vendors requiring browser storage access in third-party context, these broad impacts can be observed:\nAbility to build graphs and profiles of users is restricted. Ability to target ads based on graphs and profiles of users is restricted. Ability to manage ad frequency is restricted. Ability to model attribution for view-through conversions is restricted. Ability to participate in cookie matching is restricted. Ability to provide demographics and interest data for analytics systems is restricted. For vendors needing browser storage access in first-party context, these handicaps are in place:\nAbility to attribute conversions to ad clicks is somewhat restricted. Ability to measure efficiency of advertising is somewhat restricted. Ability to look back beyond the last touch in attribution models is somewhat restricted. \u0026ldquo;Somewhat restricted\u0026rdquo; above refers to the fact that out of the major browsers, only Safari is currently restricting first-party storage access. Thus the severity of these restrictions depends on the typical share of Safari traffic on the advertised website.\nDigital analytics Digital analytics is an industry that measures, among other things, the effectiveness and return on investment of advertising.\nThere are analytics ventures that rely on cross-site tracking to analyze how uses are navigating across the websites of the internet, though much of this analytics is often done in addition to the primary focus of targeted advertising.\nHowever, there is an industry of first-party analytics, where the focus is on users who browse the website (or websites) of the organization, providing data and information about user behavior. This data can then be used to improve the user experience of the site, to build more effective campaigns, and to attribute conversions to different channels.\nGoogle Analytics is the most popular web analytics platform in use On Chrome, Firefox, and Edge, the capabilities of digital analytics are not really restricted. Because much of digital analytics works with browser storage in first-party context, the restrictions on known trackers in third-party context do not impact the capability to monitor users browsing the website itself.\nHowever, on Safari, especially since ITP 2.1, the accuracy of first-party analytics has been compromised as well.\nWeb analytics tools such as Google Analytics drop a first-party cookie when the user first visits a website. This cookie is typically given a long expiration, such as two years, and the cookie expiration is reset each time a Google Analytics script runs on the page.\nThe cookie value is random and unique - by default Google Analytics uses a random number and the timestamp of when the cookie was set (e.g. GA1.2.123456789.1575363021), but sometimes the identifier is just a UUID.\nGoogle Analytics uses this cookie to identify that the separate hits coming from a user\u0026rsquo;s browser belong, in fact, to the same browser.\nITP impact on first-party analytics Because this cookie is set with JavaScript, Safari\u0026rsquo;s ITP restricts its expiration to the maximum of 7 days. This means that as long as the user visits the site with fewer than 7 days between each visit (and don\u0026rsquo;t flush cookies for any other reason), they would be considered the same user. But if the visit frequency ever goes past 7 days, the user\u0026rsquo;s cookie is reset and they would be considered a \u0026ldquo;New user\u0026rdquo; by the analytics tool.\nWith ITP 2.2, cookie expiration is reduced to 1 day if the user followed a decorated link from a known tracker (e.g. a Google ad click), making it even more difficult to analyze user behavior past a very short time window.\nWebsites can move these identifier cookies to HTTP responses rather than have them be set with JavaScript. For now, this would preserve the expiraton of such cookies.\nReferrer downgrade impacts web analytics as well, because these platforms often provide channel data based on campaign identifiers in the URL and/or information stored in the referrer string. By downgrading referrers to their origins, web analytics tools can no longer accurately measure which particular page brought the user to the current site.\nUser experience optimization Here, user experience optimization covers the broad topics of conversion (rate) optimization and content personalization. The purpose of such efforts is to dynamically alter what the user might see on a website, based on random distribution to different variants, or based on targeting algorithms that choose the most suitable variant or content for the user.\nFor experimentation and data collection, it\u0026rsquo;s important that the user\u0026rsquo;s experience on the site be consistent. Being exposed to a different variant of the site with every page load can lead to confusion and introduce friction, especially in ecommerce contexts.\nStorage specification on the Optimizely platform https://bit.ly/2YdKmVG To ensure consistency, optimization platforms set identifiers in the user\u0026rsquo;s browser storage that tells these platforms which experimentation variant or personalization group they belong to. This storage would typically be accessed in a first-party context, but if the optimization derives targeting parameters from a global profile, the storage access might be required in a third-party context, too.\nBecause the vendors often provide their solutions using global content delivery networks (CDN), these domains tend to get blacklisted in browsers\u0026rsquo; tracking protection lists and algorithms. Thus their capability to deliver experiences based on data harvested from third-party storage is compromised.\nSimilar to digital analytics, first-party storage for content optimization is also restricted on Safari. Due to the short expiration time of script-writable storage, experimentation and personalization platforms can\u0026rsquo;t deliver consistent experiences. In addition to this, the inability to control the sample sizes and deduplicate conversions often leads to too much noise in the calculation of statistical significance for the experimentation variations.\nOptimization platforms and websites running them should look into utilizing HTTP headers for getting and setting these cookies and for determining which content to show to the user, rather than the JavaScript APIs that have been compromised by Safari\u0026rsquo;s ITP.\n"
},
{
	"uri": "https://www.cookiestatus.com/chrome/",
	"title": "Chrome",
	"tags": [],
	"description": "",
	"content": "Current status Chrome\u0026rsquo;s initiative for browser tracking protections (among other things) is called Privacy Sandbox. While Chrome\u0026rsquo;s pledge to remove third-party cookies has been put on hold, the project includes many other interesting features, such as storage partitioning (see below).\nClassification of \u0026ldquo;known trackers\u0026rdquo; Chrome does not classify classify trackers or domains for the purposes of tracking protection.\nThird-party cookies Chrome restricts the maximum lifetime of cookies to 400 days.\nFirst-party cookies Chrome restricts the maximum lifetime of cookies to 400 days. Other than that, Chrome does not restrict the use of first-party cookies.\nOther third-party storage Chrome partitions storage in embedded frames that load content from a cross-site origin.\nExample: If siteA.com tries to load an iframe from siteB.com, the latter will have access to its storage (localStorage, for example). However, these storage mechanisms are partitioned between siteA.com and siteB.com. If a second site, such as siteC.com loads a frame from siteB.com, the storage the latter will have access to will not be the same as that available when embedded via siteA.com.\nOther first-party storage Chrome does not restrict the use of other browser storage in first-party context.\nCNAME cloaking No protections against CNAME cloaking.\nReferrer Chrome 85 sets the default referrer policy to strict-origin-when-cross-origin. This means that for cross-origin requests (e.g. sub.domain.com to othersub.domain.com, or sub.domain.com to sub.otherdomain.com) the referer HTTP header and document.referrer JavaScript API are truncated to show just the origin of the website making the request. Thus a page such as https://www.domain.com/some-page?param=value would show up just as https://www.domain.com in the referrer records.\nOther On macOS Chrome, the version number in the User Agent string is frozen to 10_15_7 to fix compatibility issues with upgrading to macOS version 11+ (Big Sur). This has obvious privacy implications as well, as the platform version is no longer useful for fingerprinting purposes.\nSample User Agent string when running Chrome 90.0.4430.212 on macOS 11.3.1: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\u0026quot;\n"
},
{
	"uri": "https://www.cookiestatus.com/edge/",
	"title": "Edge",
	"tags": [],
	"description": "",
	"content": "Current status Detail Description Mechanism Tracking prevention Originally deployed in 78.0.276.8 Latest update deployed in 79 Latest update includes Site and organization mitigation to choosing which trackers to block. User controls Customizable settings to: Choose between Basic, Balanced or Strict modeView trackers that have been blockedAdd sites to list of exceptions for which trackers should always be allowed to runCheck your site engagement scores Edge Tracking prevention settings Classification of \u0026ldquo;known trackers\u0026rdquo; Edge uses Trust Protection Lists to classify the domains that are recognized as having cross-site tracking capabilities, or are otherwise harmful to the site. This list is derived from Disconnect.me, similar to Firefox\u0026rsquo;s approach.\nEdge restricts storage access to and/or blocks resources loaded from the following Disconnect.me categories:\nAdvertising Analytics Content Cryptomining Fingerprinting Social The chart below shows the level of blocking for each category. Balanced is the default level of tracking prevention in the browser.\nFrom: https://bit.ly/39PlJ6S S means that storage access is restricted for domains falling under the given category.\nB means that all resources are blocked for domains falling under the given category.\nTo prevent storage access and resource blocking from breaking user experience, Edge has introduced some mitigations to how cross-site tracking prevention works.\nSame-org mitigation If two domains are owned and operated by the same company, Edge introduces a mitigation where tracking prevention is relaxed when one such domain requests resources from the other.\nExample: www.company-domain.com and www.company-cdn.com are different domains, but they are registered by the same company, and Edge recognizes them as belonging to the same organization. Thus, even if Edge\u0026rsquo;s Trust Protection Lists have identified www.company-cdn.com as a tracking domain, access to it from www.company-domain.com would not be restricted.\nSite engagement mitigation Edge introduced the Site engagement score from the Chromium project as a further mitigation to accessing resources on classified domains.\nActivities that improve the site engagement score are:\nDirect navigations to the site (so typing the URL in the address bar or following a bookmark - navigation via link clicks, for example, would not improve the score) Active time on site (defined by time spent by clicking, scrolling, using the keyboard) Media playback on the site The site engagement score is calculated as a double value between 0-100.\nEngagement scores are keyed by origin (so www.domain.com would have a different engagement score from sub.domain.com), and engagement scores are cleared with browser history (or, for scores accumulated in incognito mode, when the browser is shut down). Engagement scores also decay with time.\nEdge determines a score of 4.1 to represent sufficient engagement with a site to enable mitigation for tracking prevention.\nYou can view the site engagement scores stored in your Edge instance by typing edge://site-engagement in the address bar of the browser.\nIf the browser requests a resource from a site with an engagement score of 4.1 or better, Edge does not restrict storage access or resource loads unless the site is classified in the Fingerprinting or Cryptomining categories.\nOrg engagement mitigation Organization engagement mitigation means that if one site in an organization receives a site engagement score high enough to not be impacted by tracking prevention (i.e. a score of 4.1 or better), then the user is considered to have a relationship with the organization.\nExample: If the user has interacted with www.company-domain.com enough to accumulate a score of 4.1 or better, then www.company-cdn.comwould enjoy the benefits of site engagement mitigation as well, because it is recognized as part of the same organization. Thus if a website does a cross-site request to www.company-cdn.com, Edge would not block storage access even if the domain were in the Trust Protection Lists. Unless, of course, www.company-cdn.com would fall under the Fingerprinting or Cryptomining categories.\nThird-party cookies Third-party cookies are blocked from all domains listed in the Trust Protection Lists (considering the mitigations listed above).\nFirst-party cookies No restrictions.\nNote that domains in Cryptomining and Fingerprinting categories of the Trust Protection Lists have all resource loads blocked, and thus resources that would have been downloaded from these sources cannot make use of first-party cookies.\nOther third-party storage All other third-party browser storage is blocked from domains listed in the Trust Protection Lists (considering the mitigations listed above).\nOther first-party storage No restrictions.\nNote that domains in Cryptomining and Fingerprinting categories of the Trust Protection Lists have all resource loads blocked, and thus resources that would have been downloaded from these sources cannot make use of other first-party storage.\nCNAME cloaking No protections against CNAME cloaking.\nReferrer Default browser policy (strict-origin-when-cross-origin).\nOther On macOS Edge, the version number in the User Agent string is frozen to 10_15_7 to fix compatibility issues with upgrading to macOS version 11+ (Big Sur). This has obvious privacy implications as well, as the platform version is no longer useful for fingerprinting purposes.\nSample User Agent string when running Edge 90.0.818.62 on macOS 11.3.1: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36 Edg/90.0.818.62\u0026quot;\n"
},
{
	"uri": "https://www.cookiestatus.com/firefox/",
	"title": "Firefox",
	"tags": [],
	"description": "",
	"content": "Current status Detail Description Mechanism Enhanced Tracking Protection (ETP) Originally deployed in 69.0 Latest update deployed in June 14, 2022 Latest update includes Total Cookie Protection rolled out to all users. User controls Choose between Standard, Strict, and Custom levelsIn Custom level, select which types of trackers and scripts to blockAdd exceptions to the domains blocked by Enhanced Tracking Protection Enhanced Tracking Protection levels Classification of \u0026ldquo;known trackers\u0026rdquo; Firefox uses the Disconnect.me lists to establish the domains that fall under ETP measures.\nFirefox utilizes the following Disconnect.me categories in ETP:\nAdvertising - third-party cookies blocked Analytics - third-party cookies blocked Cryptomining - all third-party requests blocked Fingerprinting - third-party requests blocked conditionally Social - third-party cookies blocked Example: If the browser sends a request to www.facebook.com (a known tracker), no cookies would be sent with the request.\nTracking Content blocking (enabled in Private windows by default) will not just strip cookies but actually block all resource requests to domains listed in Disconnect.me.\nFirefox deletes all stored site data (incl. cookies, browser storage) if the site is a known tracker and hasn\u0026rsquo;t been interacted with in the last 30 days.\nThird-party cookies Third-party cookies are blocked for classified domains.\nWith Total Cookie Protection, Firefox partitions storage between the site and the third-party embedded on the site.\nExample: If siteA.com tries to load a resource from siteB.com, the latter will have access (assuming it is not on the list of known trackers) to its cookies. However, these cookies are stored in a special partition keyed between siteA.com and siteB.com. If a second site, such as siteC.com loads a resource from siteB.com, the cookies the latter will have access to will not be the same as those available when embedded via siteA.com.\nThere are some edge cases where a partitioned third-party is granted unpartitioned access to its embedder. These involve pop-up windows and redirects, and you can read more about them here.\nFirst-party cookies All storage is cleared (more or less) daily from origins that are known trackers and that haven\u0026rsquo;t received a top-level user interaction (including scroll) within the last 45 days. More details can be found here.\nNote that domains in the Cryptomining category have all incoming requests blocked by Firefox, and thus scripts loaded from these domains will not be able to interact with first-party cookies. Similarly, domains that are both in the Fingerprinting and some other tracking category have incoming requests blocked and the downstream impact is the same.\nOther third-party storage For classified domains, localStorage and IndexedDB are restricted.\nExample: JavaScript running in an iframe, which loads content from a known tracking domain, tries to write to localStorage within that iframe. Firefox blocks this activity, because localStorage is disabled in third-party context if the domain is classified as a known tracking domain.\nsessionStorage is not restricted.\nWith Total Cookie Protection, all browser storage is partitioned in third-party context. See the example above for more information.\nOther first-party storage All storage is cleared (more or less) daily from origins that are known trackers and that haven\u0026rsquo;t received a top-level user interaction (including scroll) within the last 45 days. More details can be found here.\nNote that domains in the Cryptomining category have all incoming requests blocked by Firefox, and thus scripts loaded from these domains will not be able to interact with other first-party storage. Similarly, domains that are both in the Fingerprinting and some other tracking category have incoming requests blocked and the downstream impact is the same.\nCNAME cloaking No protections against CNAME cloaking.\nReferrer The default referrer policy is strict-origin-when-cross-origin. More relaxed policies are not permitted.\nIf the referring URL has a tracking parameter (e.g. fbclid), the document.referrer string is truncated to eTLD+1.\nExample: If the user browses from https://www.my.domain/purchase-page?fbclid=12345 to https://www.my.domain/home-page/, the document.referrer string will show just https://my.domain/.\nOther If the domain is in the Fingerprinting category of Disconnect.me and in one of the tracking categories (Advertising, Analytics, or Social), all third-party requests to the domain are blocked.\nOn macOS Firefox, the version number in the User Agent string is frozen to 10.15 to fix compatibility issues with upgrading to macOS version 11+ (Big Sur). This has obvious privacy implications as well, as the platform version is no longer useful for fingerprinting purposes.\nSample User Agent string when running Firefox 88.0.1 on macOS 11.3.1: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:88.0) Gecko/20100101 Firefox/88.0\u0026quot;\n´\n"
},
{
	"uri": "https://www.cookiestatus.com/safari/",
	"title": "Safari",
	"tags": [],
	"description": "",
	"content": "Current status Detail Description Mechanism Intelligent Tracking Prevention 2.3 Originally deployed in Safari 13 in iOS 13, macOS Catalina, Mojave, and High Sierra User controls ITP doesn\u0026rsquo;t let users control how it works. Users can simply toggle ITP off by unchecking \u0026ldquo;Prevent cross-site tracking\u0026rdquo; in Safari\u0026rsquo;s Security preferences. Privacy controls in Safari For a comprehensive overview of all WebKit\u0026rsquo;s tracking preventions, see this document.\nClassification of \u0026ldquo;known trackers\u0026rdquo; Since introducing the Privacy Report in Safari 14, Safari has been using the Tracker Radar to classify origins as \u0026ldquo;known trackers\u0026rdquo;. This is mainly used to provide content for the Privacy Report, and has no real functional value. However, Safari\u0026rsquo;s IP obfuscation, released in Safari 15, utilizes these \u0026ldquo;known trackers\u0026rdquo; to determine in which requests the user\u0026rsquo;s IP address should be obfuscated.\nOther than the above, Safari classifies domains capable of cross-site tracking using an algorithm that runs on-device. Thus each Safari user has a potentially different list of domains that are blocked from having access to browser storage.\nThe algorithm is superficially described in this blog post:\nA machine learning model is used to classify which top privately-controlled domains have the ability to track the user cross-site, based on the collected statistics. Out of the various statistics collected, three vectors turned out to have strong signal for classification based on current tracking practices: subresource under number of unique domains, sub frame under number of unique domains, and number of unique domains redirected to. All data collection and classification happens on-device.\nIf a domain is classified by Safari as having cross-site tracking capabilities, it will have several restrictions placed upon it, listed below.\nExample: A website loads an iframe from www.iframe-domain.com. This is the first time the user\u0026rsquo;s browser has loaded content from this domain in a frame. ITP does not yet react to this, as it\u0026rsquo;s a single occurrence. Later, the user visits multiple different websites, all loading data from the same domain into an iframe. At this point, ITP classifies the domain as having cross-site capabilities, and the restrictions listed on this page will be put into effect.\nTo monitor the list of domains classified by your Safari instance, or to test ITP in action, you can utilize the ITP Debug Mode, with instructions for use found behind this link.\nThird-party cookies Safari blocks all access to cookies in third-party context.\nTo support legacy federated login scenarios, an exception to the rule above is a temporary compatibility fix that was introduced in ITP 2.0. This fix applies to scenarios where a site opens a pop-up to a federated login service and then relies on third-party cookies to persist the login on the site itself. ITP detects this type of pop-up behavior and forwards third-party storage access to the site after the login service sets the cookie (in third-party context).\nNote that this is listed as a temporary fix and could be invalidated at any time. Because the pop-up already requires user interaction (the login action itself), WebKit recommends to use the Storage Access API for proper handling of third-party storage access (see below).\nStorage Access API Safari introduced the Storage Access API in February 2018. With the Storage Access API, a website can ask the user\u0026rsquo;s permission to access storage in an embedded cross-site resource which would otherwise have its cookie access restricted.\nTo be able to use the Storage Access API, the embedded site must have been interacted with in first-party context (URL in address bar) in the last 30 days of Safari use.\nExample: The user is on www.blog-site.com, which loads a comment service in an \u0026lt;iframe\u0026gt; from www.comment-service.com. Since this is a cross-site resource load, ITP will not allow storage access due to the site not having prior cookies set (Safari\u0026rsquo;s default cookie policy), and because the user hasn\u0026rsquo;t interacted with the site in first-party context in the last 30 days of Safari use.\nRequesting storage access via the API If the user has interacted with the embedded site in first-party context in the last 30 days of Safari use, and the site has cookies set, the site can call the Storage Access API upon a user interaction in the embed (such as a click or tap), after which Safari will prompt the user if they want to allow the embedded site to access its storage.\nExample: The user visits www.comment-service.com, and logs into the service. The service sets a cookie in first-party context to save the user\u0026rsquo;s login state. Then, the user browses to www.blog-site.com, which embeds www.comment-service.com in an \u0026lt;iframe\u0026gt;. In the \u0026lt;iframe\u0026gt;, the user clicks a button which initiates a login state check on www.comment-service.com. This time, www.comment-service.com uses the Storage Access API, and the user is prompted if they want to allow www.comment-service.com to access its first-party storage. If the user allows it, the embedded site will have access to its cookies, even though it is running in a third-party context.\nIf the user doesn\u0026rsquo;t interact with the site again in first-party context in 30 days of Safari use, Safari will clear all storage from the embedded site, and prevent any new storage from being set. This will continue until the user interacts with the site in first-party context again.\nNote that successful use of the Storage Access API (either clicking \u0026ldquo;Allow\u0026rdquo; on the prompt, or interacting with the embed after having clicked \u0026ldquo;Allow\u0026rdquo; previously) is interpreted as interaction in first-party context, which means the 30 day timer is reset in such scenarios! This allows the embed to keep accessing its first-party storage even if the user doesn\u0026rsquo;t visit the embedded site in first-party context.\nFirst-party cookies Safari deletes all script-writable storage on websites if the site has not been interacted with (click, tap, keyboard input) in first-party context in the last 7 days of browser use. This includes cookies set with document.cookie.\nExample: The user visits www.domain.com, where JavaScript is used to set a cookie that expires in 365 days. Over the next 100 days, the user uses the browser 6 times in total, but does not visit www.domain.com or interact with the site. If the user uses the browser one more time without interacting with www.domain.com, the cookie will be deleted even if its expiration date is not met.\nIf the referring domain is a known tracker, and if the URL has query parameters (?key=value) or fragments (#somevalue), cookies set with JavaScript\u0026rsquo;s document.cookie API have a maximum expiration of 24 hours.\nExample: The user follows a link from www.facebook.com (a known tracking domain), and lands on the website. Facebook appends an ?fbclid=123123123123 parameter to the URL. Because the referring URL is on a classified domain, and because the landing page has a query parameter, ITP sets a maximum expiration of 24 hours to any cookies set with JavaScript while on that landing page.\nFirst-party cookies set with the Set-Cookie HTTP response header are not impacted by ITP, and have no restrictions placed on their expiration, unless they meet the criterion for CNAME cloaking (see below)..\nOther third-party storage localStorage is partitioned, so that access is keyed to the combination of the source and target domains. Thus www.domain.com has a different localStorage store in third-party context when accessed from www.domain1.com and from www.domain2.com. This partitioned store is also cleared between application launches.\nsessionStorage is partitioned in a similar way (source).\nIndexedDB is restricted.\nOther first-party storage All script-writable storage is deleted in 7 days of browser use since last interaction with the site (click, tap, or text input). This includes these mechanisms:\nCookies set with document.cookie (see above). IndexedDB LocalStorage Media Keys SessionStorage Service Worker registrations and cache CNAME cloaking If a subdomain has a CNAME alias to a cross-site origin, then any cookies set with Set-Cookie HTTP response headers will be restricted to a maximum 7 day expiration.\nIf a subdomain is set with A/AAAA records that resolve to an IP address where the first half of the address does not match the first half of the IP address for the website the user is currently browsing, then any cookies set with Set-Cookie HTTP repsonse headers will be restricted to a maximum 7 day expiration.\nExample: A site on https://domain.example uses the subdomain https://tracker.domain.example to set cookies in order to avoid WebKit\u0026rsquo;s restrictions on script-writable first-party storage. However, https://tracker.domain.example/ has a CNAME alias to https://domain.cloud.endpoint, where the web server handling this logic resides. On desktop Safari (on Big Sur) and all major iOS and iPadOS browsers, any cookies set with HTTP responses from https://tracker.domain.example will now be restricted to an expiration of maximum 7 days.\nExample: The user is browisng https://domain.example which resolves to an IP address of 100.100.100.100. The website makes a request to https://tracker.domain.example which resolves to an IP address of 200.200.200.200. On the Safari browser, any cookies set with HTTP responses from https://tracker.domain.example will be restricted to an expiration of maximum 7 days.\nReferrer Safari downgrades document.referrer to origin in cross-site navigation.\nSafari downgrades the referrer in cross-site request headers to origin. Thus if a page on https://www.domain.com/page/page.html tried to load an image from https://images.imagecdn.com, the referer header would show https://www.domain.com rather than the full referrer.\nFurthermore, if the referring domain is a known tracker, and if the referring page has query parameters (?key=value) or fragments (#somevalue), the document.referrer property is downgraded to effective top-level domain plus one part (eTLD+1). Thus a request originating from https://sub.classified.domain.com/page?userId=abcd1234 would end up as https://domain.com in the document.referrer property of the landing page.\nNote that the above restrictions only apply if the site tries to set a Referrer Policy of unsafe-url or no-referrer-when-downgrade. In other words, Safari effectively prevents the referrer policy from being relaxed so that anything beyond the origin is sent in cross-site requests.\nSafari has the default Referrer Policy of strict-origin-when-cross-origin.\nOther Safari also protects against first-party bounce tracking. Bounce tracking happens when instead of navigating the user directly to the target domain, the user is redirected through intermediate domains which can set cookies and build a profile of the user. Intelligent Tracking Prevention detects when domains are used solely for bounce tracking and clears all website data that might have been saved on them.\nSimilarly, Safari protects against tracker collusion, where multiple tracking domains in a redirect chain can feed information to each other to build a comprehensive profile of the user. If one domain in this chain is classified as having cross-site tracking capabilities, then all domains in the redirect chain will be classified as well.\nWith Safari 14, WebKit\u0026rsquo;s tracking preventions are extended to all browsers running on the iOS platform. There is no way for the browser or any app using the browser to toggle these protections off. Only the user can opt-out of cross-site tracking protections.\nWebKit browsers also delete all site data (script-writable storage, all cookies) if the site domain has been classified by ITP and if there has been no meaningful interaction with the site in first-party context in the last 30 days. Granted access through Storage Access API resets the timer as well.\nWith Safari 15, the browser hides the user\u0026rsquo;s actual IP address in requests sent to origins that are listed in DuckDuckGo\u0026rsquo;s Tracker Radar list.\nOn macOS Safari, the version number in the User Agent string is frozen to 10_15_7 to fix compatibility issues with upgrading to macOS version 11+ (Big Sur). This has obvious privacy implications as well, as the platform version is no longer useful for fingerprinting purposes.\nSample User Agent string when running Safari 14.1 on macOS 11.3.1: \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1 Safari/605.1.15\u0026quot;\n"
},
{
	"uri": "https://www.cookiestatus.com/cliqz/",
	"title": "Cliqz",
	"tags": [],
	"description": "",
	"content": "Current status The Cliqz project has been shut down, unfortunately. However, their information will be kept live on this site as a homage to the pioneering work Cliqz did for browser tracking protections.\nDetail Description Mechanism Anti-Tracking Originally deployed in 1.30.0 Latest update deployed in 1.32.1 Latest update includes All cross-origin referrers stripped to origin. User controls Site-specific and global controls for: Anti-tracking activationBlocking adsCookie pop-up blocking (consent requests)Anti-phishingAutomatic HTTPS connection upgrade Cliqz Anti-Tracking default settings Classification of \u0026ldquo;known trackers\u0026rdquo; Cliqz uses an algorithmic classification model for identifying trackers with cross-site tracking capabilities.\nThis model is run both locally (in the user\u0026rsquo;s browser) and globally (derived from a global database, periodically updated with data from local contexts).\nTo understand this better, read this research paper:\nWhoTracks .Me: Shedding light on the opaque world of online tracking\nYou can also browse the whotracks.me service to learn about the status of the global tracker database Cliqz uses.\nThird-party cookies Known trackers have third-party cookie access blocked. There is a heuristical model in place to determine exceptions to this rule. The model includes (source):\nUser interaction with the 3rd party widget. When an element is clicked, Cliqz looks for tracker domain access within the embedded element and temporarily whitelists cookie access for the domain. Redirects. When a domain redirects to a classified domain, the classified domain is whitelisted for temporary cookie access. This is to preserve things like login flows that handle state with cookies. OAuth detection. OAuth flows can be identified fairly easily, and classified domains are whitelisted for temporary access to cookies necessary to keep the flow running. Cookies that are set on classified domains without first-party interaction (i.e. as third-party cookies) have a maximum expiration set to 1 hour.\nFirst-party cookies How first-party cookies expire is determined by a) whether the domain the cookies are set on is a classified domain, and b) how frequently the classified domain is visited in first-party context.\nIf the domain is not a classified domain, first-party cookies have a maximum expiration of 7 days (if set without the HttpOnly flag) or 30 days (if set with the HttpOnly flag).\nExample: A JavaScript SDK (e.g. an analytics) tool writes a cookie in the user\u0026rsquo;s browser, assigning them with an anonymous, randomly generated client identifier. The purpose of this identifier is to assign multiple visits by the same browser to the same \u0026ldquo;user\u0026rdquo;. If the user visits the site within 7 days of the previous visit, the cookie will persist in the browser, and the analytics platform will be able to identify the browser as one that has previously visited the site. If the visits happen more than 7 days apart, the user will always be a \u0026ldquo;new user\u0026rdquo; to the analytics platform.\nIf the domain is a classified domain, then infrequent visits to the domain impose a maximum expiration of 7 days to the first-party cookie. If the domain is visited frequently, the maximum expiration is set to 30 days (with the HttpOnly limitation same as above).\nOther third-party storage No current restrictions.\nOther first-party storage No current restrictions.\nReferrer Cliqz strips all cross-origin referrers to origin only.\nExample: The user clicks on a link from https://www.company.com/page?userId=123 to https://www.cookiestatus.com/. The referer HTTP header and the document.referrer JavaScript object will show https://www.company.com as the referrer. All non-navigational HTTP requests will truncate the referrer in a similar fashion.\nCNAME cloaking No protections against CNAME cloaking.\nOther Cliqz automatically purges potential user identifiers from the URL, headers, and POST data of third-party requests.\nThe model tokenizes all key-value pairs found, and then evaluates the values against a set of rules to determine if it\u0026rsquo;s safe (should not be removed) or unsafe (should be removed).\nThis evaluation is done locally first, and then the values are compared against a global safe set (derived from data collected from global Cliqz usage). If the value is flagged as unsafe and does not have a match in the global set, it is purged from the request.\nExample: If the browser sends a request to a third-party resource using something like ?userId=abcd-1234-efgh-5678 in the request URL, it\u0026rsquo;s possible that this parameter will be stripped from the outgoing request so that the service receiving the request will not be able to access the data.\nThis article has an excellent overview of how this process works (beginning with chapter titled Unsafe Data Removal).\n"
},
{
	"uri": "https://www.cookiestatus.com/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "This is a glossary of terms used in the website.\nAdTech Term used to describe advertising technologies and the companies and vendors working in AdTech. Many AdTech vendors utilize cross-site tracking to exploit user data in browser storage.\nAnalytics Industry, vendors, tools, platforms, and methodologies grouped together by the pursuit of empirical data for measuring things like web performance, user behavior and advertising efforts.\nOften focuses on data collection in a first-party context, but especially in AdTech, analytics tools are used for collecting and analyzing data in third-party context as well.\nChromium An open-source web browser project, used as the foundation of a variety of browsers (e.g. Brave and Edge (Beta)).\nMuch of the technology in Chromium is also used in the Chrome browser, but the two projects diverge when it comes to the full tech stack.\nConversion An event or metadata of a user, collected by analytics tools and AdTech platforms to calculate the efficiency of campaigns and of content optimization and personalization efforts.\nEach organization can have their own interpretation of what a conversion is, but typically it is something that has a measurable impact on the business bottom line.\nCookie A key-value pair (e.g. userStatus=logged-in) stored in the user\u0026rsquo;s computer. Cookies are keyed to the domain on which they were set. Accessing cookies in same-site requests occurs in first-party context, and such cookies are termed first-party cookies. Cross-origin access happens in third-party context and these cookies are called third-party cookies.\nCookie matching / syncing Data management platforms (DMP) and demand-side platforms (DSP) can exchange user information in their own data stores, mapping each platform\u0026rsquo;s own list of users to other lists by utilizing shared keys in third-party storage.\nThis way a DMP can build a comprehensive graph of a user\u0026rsquo;s cross-site navigation on the web without actually having their own data collection architecture present on all the websites.\nCross-origin \u0026ldquo;Origin\u0026rdquo; is the protocol (e.g. https), hostname (e.g. www.domain.com) and port (e.g. 4097) of the URL. If the origin of the site where the request was sent from differs from the origin of the site the request is sent to, the request is considered to be cross-origin.\nFor example:\nA request from https://www.domain.com/page.html to https://www.domain.com/images/image.jpg is same-origin, as both the source and target share the origin. A request from https://www.domain.com/page.html to https://images.domain.com/images/image.jpg is cross-origin, as the source and target do not share the origin. Cross-site Cross-site is a type of cross-origin communication, but it\u0026rsquo;s more rigid as it requires that the source and target of the request do not share the effective top-level domain plus one part (eTLD +1).\nFor example:\nA request from https://www.domain.com/page.html to https://images.domain.com/images/image.jpg is cross-origin and same-site, as the eTLD+1 (domain.com) is shared by the source and target. A request from https://www.domain.com/page.html to https://imagesource.domaincdn.com/images/image.jpg is cross-origin and cross-site, as the eTLD+1 (domain.com and domaincdn.com) is different between the source and target. Cross-site tracking Cross-site tracking refers to a tracking domain harvesting data from user\u0026rsquo;s navigation and actions on other, unrelated sites. This is typically done by storing an identifier in a cookie on the tracking domain, and communicating with the tracking domain in a third-party context.\nCross-site tracking happens covertly, and the user typically has no knowledge of all the data that has been collected from them while browsing the web.\nDomain hierarchy Domain (or DNS) hierarchy refers to the domain names in a given domain name string (fully qualified domain name). With the document.cookie JavaScript API, the browser can read and write cookies on the current domain and all the domains higher in the hierarchy, all the way to eTLD+1.\nThus a user browsing a site on sub.blog.domain.com can read and write cookies on sub.blog.domain.com, blog.domain.com and domain.com.\nEnhanced Tracking Protection (ETP) The name of the tracking protection mechanism in the Firefox web browser.\nETP uses the Disconnect.me lists to determine whether a given domain is a known tracker or not.\neTLD+1 Effective top-level domain plus one part. eTLD would comprise the top-level domain (e.g. .com and .uk) and sometimes a second-level of hierarchy (e.g. .co in .co.uk or .com in .com.au). Thus eTLD is the same thing as the Public Suffix.\nThe \u0026ldquo;one part\u0026rdquo; is then the next level in the domain hierarchy, i.e. the domain name the site would have acquired to map to their servers.\nThe eTLD+1 term is used in particular by Safari\u0026rsquo;s Intelligent Tracking Prevention documentation to refer to the highest domain name the browser has read/write storage access to.\nFirst-party In the context of storage access, first-party references the domain the user is currently on. Browser storage is typically completely restricted to the first-party.\nCookie access is a bit different, as the browser can access cookies in a first-party context on the domain they are on and on any domain higher up in the domain hierarchy (all the way to eTLD+1).\nIntelligent Tracking Prevention (ITP) The name of the Safari browser\u0026rsquo;s tracking protection mechanism and related tools.\nDue to its wide-spread use (especially on mobile devices), its algorithmic evaluation of tracking domains, and its impact on first-party storage, ITP has been a big disruption on AdTech and analytics industries.\nLink decoration The act of adding URL query string parameters (e.g. https://www.domain.com?id=12345 or hash fragments (e.g. https://www.domain.com/#id=12345) to outbound links from a website with the purpose of passing some key-value pairs from first-party storage to another site without having to worry about third-party storage access restrictions.\nSince the values are passed in the URL, the target site can access them by simply taking them from the URL string.\nPageGraph PageGraph is a tool built for the Brave browser, which analyzes the way in which a web document operates (and is operated on) within the browser.\nPageGraph builds a representation of things like node changes, network requests, and script execution, so that this research could be used to, for example, optimize the privacy-preserving feature restrictions of the browser that produced the graph.\nQuantum The browser engine used by the latest versions of the Firefox browser. It\u0026rsquo;s an improved / redesigned iteration of Firefox\u0026rsquo;s original Gecko engine.\nReferrer When the web browser issues a request to a web server, that request often includes the referer [sic] header to indicate the URL the request originated from.\nIf the target resource is a web page, i.e. the request originated from a link click, when the web page is rendered the referrer string is written into the document.referrer property.\nDue to its capability to carry information that could be utilized in cross-site tracking contexts, browsers are actively working towards making the referrer string less informative by a process called referrer downgrade or by completely stripping and/or spoofing it.\nReferrer downgrade Downgrading the referrer means stripping out parts of it that could be utilized for cross-site tracking or carrying sensitive information.\nBrowsers are working on defaulting to strict-origin-when-cross-origin, which would mean that for request outside the current domain namespace the referrer would be stripped of its path, query, and fragment parts. Thus https://www.sourcedomain.com/some-page-with-link/?id=12345 would become https://www.sourcedomain.com in the referer header.\nThe Brave browser strips the referrer in all navigational cross-origin requests (e.g. clicking on a link to move to another page). For other cross-origin requests, the referrer header is spoofed to contain the origin being requested rather than the origin being referred from.\nScript-writable storage Refers to browser storage that can be accessed with JavaScript. Typically this would be browser cookies, localStorage, sessionStorage, and IndexedDB.\nThird-party In the context of storage access, third-party means that the browser is trying to access storage that is not on the current domain.\nFor example, while on web.domain.com if the browser makes a request for an image on image.imagestore.com, the request would have access to cookies written on image.imagestore.com only if the browser did not block third-party cookies. Similarly, if the response from image.imagestore.com tries to write a cookie with a Set-Cookie header, this would only work if the browser allowed third-party cookies.\nIf the web browser loaded another domain\u0026rsquo;s content in an \u0026lt;iframe\u0026gt; element, then any storage access (using e.g. document.cookie or localStorage) within that \u0026lt;iframe\u0026gt; would happen in a third-party context.\nWebKit A browser engine developed by Apple and used as the engine for the Safari browser and all the iOS browsers.\n"
},
{
	"uri": "https://www.cookiestatus.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]