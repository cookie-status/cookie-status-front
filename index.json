[
{
	"uri": "https://www.cookiestatus.com/",
	"title": "Cookie Status",
	"tags": [],
	"description": "",
	"content": "Cookie Status The cookiestatus.com website is a knowledge sharing resource for the various tracking protection mechanisms implemented by the major browsers and browser engines.\nFor more information about the service, please consult the FAQ.\nPlease submit suggestions and corrections as issues in the GitHub project. Click here to find your way.\n Current status Changes added in the latest release are indicated with yellow highlight. You can click the  icon to be redirected to the respective section in each browser's own \u0026ldquo;Current Status\u0026rdquo; page.\n Last updated: 11 December 2019\n Suggest an edit\nToggle full screen\n    Brave Chrome Edge (Beta) Firefox Safari     Mechanism Shields n/a Tracking prevention Enhanced Tracking Protection (ETP) Intelligent Tracking Prevention 2.3 (ITP)   Deployed in 0.55.18 n/a 78.0.276.8 69.0 Safari 13 on macOS   Latest release Link Link Link Link Link   Default protection mode Default Shield settings n/a Balanced Standard ITP enabled   Classification of \u0026ldquo;known trackers\u0026rdquo;  Multiple filter lists  n/a  Trust Protection Lists (with engagement and organization mitigation)  Disconnect.me  Algorithmic   Cookies in 3rd party context  All access restricted.  No restrictions.  Access restricted for known trackers.  Access restricted for known trackers.  Access restricted if no prior interaction in first-party context. Access restricted if no prior cookies set on the domain Access restricted for known trackers.   Cookies in 1st party context  For cookies set with document.cookie, expiration set to 7 days. Otherwise maximum expiry set to 6 months.  No restrictions.  No restrictions.  No restrictions.  For cookies set with document.cookie, expiration set to 7 days. For cookies set with document.cookie, expiration set to 24 hours on pages with URL decoration (query parameters or fragments) when referring domain is a known tracker.   Other browser storage in 3rd party context  No restrictions.  No restrictions.  Access restricted for known trackers. No restrictions for other domains.  localStorage and IndexedDB restricted for known trackers. sessionStorage is not restricted. No restrictions for other domains.  localStorage is partitioned and reset between application launches. IndexedDB is restricted. sessionStorage is not restricted.   Other browser storage in 1st party context  No restrictions.  No restrictions.  No restrictions.  No restrictions.  Restricted to 7 days maximum storage on pages with URL decoration (query parameters or fragments) when referring domain is a known tracker.   Referrer  Cross-origin referrers are spoofed (set to the referred-to rather than the referred-from origin) in non-navigational HTTP requests. Cross-origin referrers are stripped in navigational HTTP requests. Same-site navigation preserves the referrer.  Default browser policy (no-referrer-when-downgrade)  Default browser policy (no-referrer-when-downgrade)  Default browser policy (no-referrer-when-downgrade)  Strip all cross-origin referrers to origin. For referrers that are known trackers, where the referring page also has URL decoration (query parameters or fragments), referrer is downgraded to eTLD+1.   Other  Removes known tracking parameters from URL query strings. n/a n/a n/a n/a     Bubbling under  Brave: Cap all script-writable storage to a maximum lifetime (link to issue) Safari: isLoggedIn (original explainer and WebKit changeset for experimental feature) Firefox, Edge, Chrome: strict-origin-when-cross-origin default referrer policy  FAQ 1. Why does this resource exist? Web browsers are going through fairly momentous shifts in order to better respond to the increasing number of data breaches and cases of data misuse by third parties.\nUnfortunately, each browser (and the underlying browser engine) seems to have their own interpretation of how to best tackle the problem, which leads to a diverse set of features across the browser landscape.\nWhat's worse, the information about how these tracking protection mechanisms are deployed is all over the place: in release notes, in developer documentation, in Twitter threads, in working groups, in feature drafts, in bug patches, etc.\nThe purpose of the Cookie Status resource is to (attempt to) collect this information in one place for easy access and perusal.\nThere is no commercial agenda behind this project. In fact, there is no agenda other than knowledge transfer.\n2. Why only these browsers? Just to kick things off. Hopefully the open-source nature of this project will invite others to contribute details about browsers that are doing significant work with regard to user privacy.\n3. What cookies / browser storage does Cookie Status set and why? Cookie Status doesn't use browser cookies, localStorage, or IndexedDB.\nsessionStorage is used to add some functionality to navigation (marking visited pages, highlighting search terms).\nNothing in browser storage is sent to any third parties at any time.\nIf you see anything contrary to the above, please raise an issue about this.\n"
},
{
	"uri": "https://www.cookiestatus.com/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction General introduction to tracking prevention / protection, what it is, and what its various implications are.\n"
},
{
	"uri": "https://www.cookiestatus.com/brave/",
	"title": "Brave",
	"tags": [],
	"description": "",
	"content": "Current status    Detail Description     Mechanism Shields   Originally deployed in 0.55.18   Latest update deployed in v1.1.20   Latest update includes Removed known user tracking parameters from query strings   User controls Site-specific and global controls for: Cross-site tracker blockingAutomatic connection upgrade to HTTPSScript blockingCookie blockingDevice recognition blocking    The Brave browser takes a very strong stance against cross-site tracking and third-party advertising. The browser proactively monitors, modifies, and blocks scripts and network resources that are deemed to compromise user privacy.\nThe browser employs a number of blocking methods, including:\n Block cookie access in third-party context Strip or spoof referrer headers in cross-site requests Neutralizes fingerprinting sources in third-party context (e.g. Canvas API, WebGL, Web Audio API) Blocks or modifies requests to known tracker sources, curated in multiple source lists including Brave's own, algorithmically derived tracker lists Removes known tracking query parameters from URLs (e.g. gclid, fbclid) Upgrades unsecure URLs to HTTPS when possible and non-disruptive  Classification of \u0026ldquo;known trackers\u0026rdquo; Third-party cookies First-party cookies Other third-party storage Other first-party storage Referrer "
},
{
	"uri": "https://www.cookiestatus.com/introduction/tracking-protection/",
	"title": "Tracking protection",
	"tags": [],
	"description": "",
	"content": "TABLE OF CONTENTS  Tracking protection, and similar measures, seek to protect the user from covert data collection and exploitation by scripts and applications created for such purposes.\nIn short, tracking protection, tracking prevention, anti-tracking, cookie blocking, content blocking, etc. are designed to:\n Identify and classify domains that utilize and distribute tracking mechanisms obstructive to (browsers\u0026rsquo; interpretation of) web user privacy. Restrict storage access in third-party context for such scripts so that the trackers cannot build cross-site profiles of web users. In some cases, restrict storage access in first-party context where it's likely that it could be exploited for cross-site tracking purposes.  In this introductory chapter, we'll gloss over some of the key terminology regarding tracking protection. You are then advised to visit the other pages of Cookie Status for more details.\n Cookies First-party and third-party context Cross-site tracking Storage access restriction  Cookies Browser cookies are key-value pairs (e.g. id=abcd1234) of information stored on the user's computer. Websites set them in order to persist information from one page to the next. This is because the web is effectively stateless - only a very limited set of information is shared from one page to the next. By writing information into browser storage, that information persists even if the pages the user navigates from are unloaded and their storage purged.\nTypical use cases for cookies include persisting a shopping cart from one page to the next on an ecommerce site, storing details about user's login status, and for setting an identifier for the user, so that their visits can be recognized in an analytics tool as originating from the same browser.\n Websites can write cookies on the user's computer, and they can read cookies from the user's computer. How effective this is depends on whether the user's browser allows cookie access in third-party context, and whether cookies in first-party context have restrictions as well.\n First-party cookies set on the current domain and on the eTLD\u0026#43;1   Reading cookies Cookies can be read and written in two ways: with HTTP headers and with JavaScript.\nThe first method relates to the browser requesting resources from a web address. This is done via an HTTP request.\nWhen the browser requests a resource from a web address, that request will include a cookie header, which includes all the cookies written on the target domain and all the domains in its domain hierarchy up to the eTLD+1.\neTLD+1 means effective top-level domain plus one part. The eTLD is the same thing as the Public Suffix. For a domain like blog.ecommerce.cookiestatus.co.uk, the eTLD would be .co.uk, and the eTLD+1 would be cookiestatus.co.uk. For a domain such as cookiestatus.github.io, the eTLD would be github.io and the eTLD+1 would be cookiestatus.github.io.\n This is what a sample HTTP request would look like with the cookie header in place:\n Sample cookie header with all cookies available on the target domain   The cookie header must respect the cookie settings in the browser. If the browser blocks third-party cookies, the cookie header is only included for requests in first-party context. Similarly, if the browser blocks all cookies, the cookie header will not be included in any requests.\nBecause the cookie header is part of the HTTP request, it means that the web server hosting the resource will be able to read this header and use this information at will.\nThe browser can read cookies with JavaScript as well.\nWhile the user is browsing a website, that website can use JavaScript to read the cookies written on the current domain and all the domains up to the eTLD+1.\nconst cookies = document.cookie; console.log(cookies); // userId=abcd1234; logged-in=true If document.cookie is invoked in a third-party context, such as an \u0026lt;iframe\u0026gt; element embedding content from a third-party source, the string will be populated only if the web browser allows third-party cookies.\nSince the cookies are readily available for any JavaScript running on the page, a malicious vendor with a script running on the site could utilize the API to read and process the cookies stored on the user's company.\nWriting cookies Similar to reading cookies, the HTTP protocol can be used to write cookies as well. The web server can return with an HTTP response including the Set-Cookie header.\nThis header is an instruction to the browser to write the included cookie(s) on the domain specified in the header.\n Sample Set-Cookie header with instructions on which domain to write the cookie   Using JavaScript, the document.cookie API can be used to write cookies, too.\nWhile on the www.cookiestatus.com domain, the following command would write a userId cookie on cookiestatus.com.\ndocument.cookie = \u0026#39;userId=abcd1234;domain=cookiestatus.com;path=/\u0026#39;; Web servers and JavaScript libraries can thus write cookies on the eTLD+1, which means they become automatically available to all subdomains of that host. Thus a script running on blog.ecommerce.cookiestatus.com can check if the user has an identifier written on cookiestatus.com, and utilize that. This can be abused for cross-site tracking purposes.\nFirst-party and third-party context It's common in the parlance of the web to talk about first-party cookies and third-party cookies. This is a bit of a misnomer. Cookies are pieces of information that are stored on the user's computer. There is no distinction between first-party and third-party in how these cookies are classified and stored on the computer.\nWhat matters is the context of the access.\nNevertheless, to align with other discussions around the same topic, Cookie Status will use first-party cookie and third-party cookie for clarity's sake.\n First-party context means that the operation happens within or across domains that share the eTLD+1. Third-party context means that the operation happens within or across domains that do not share the eTLD+1.\nHere are some examples. Consider the user to be on the domain www.cookiestatus.com.\n   Scenario Type of context eTLD+1 Details     The browser requests an image from images.cookiestatus.com. First-party context cookiestatus.com The cookie header includes all cookies written on images.cookiestatus.com and cookiestatus.com. The Set-Cookie header can write a cookie on *.cookiestatus.com.   The browser loads a JavaScript file from cdn.vendor.com. Third-party context cookiestatus.com vs. vendor.com The cookie header includes all cookies written on cdn.vendor.com and vendor.com. The Set-Cookie header can write a cookie on *.vendor.com.   The browser runs document.cookie on the page in the top frame (the main window). First-party context cookiestatus.com The command can be used to read and write cookies on www.cookiestatus.com and cookiestatus.com.   The browser loads a page from booking.vendor.com in an \u0026lt;iframe\u0026gt; and runs document.cookie on that page. Third-party context vendor.com The command can be used to read and write cookies on booking.vendor.com and vendor.com.     In the first-party context scenarios above, the cookie read/write operations will work unless the browser blocks all cookies or has cookiestatus.com in a blacklist.\nIn the third-party context scenarios, the cookie operations will work unless the browser blocks all third-party cookies, has vendor.com in the blacklist, or the possible tracking protection mechanisms have deemed vendor.com to be a tracking domain.\nCookie access in a first-party context is rarely blocked, because many features of modern websites rely on state management in the browser (using cookies or other browser storage). However, some vendors are repurposing first-party cookies for cross-site tracking, which has led to browsers (especially Safari) to place restrictions on first-party storage as well.\nAccessing cookies in a third-party context is necessary for some benign features of the web, such as persisting user authentication across the domains of an organization (SSO), or for passing information about user's marketing consent from one part of the organization to another.\nHowever, cookie access in a third-party context can be abused as well, because it can be used for cross-site tracking without the user's consent or awareness.\nCross-site tracking A common thread in the rhetoric is that browsers want to quench cross-site tracking. Here's how Safari describes it:\n Imagine a user who first browses example-products.com for a new gadget and later browses example-recipies.com for dinner ideas. If both these sites load resources from example-tracker.com and example-tracker.com has a cookie stored in the user’s browser, the owner of example-tracker.com has the ability to know that the user visited both the product website and the recipe website, what they did on those sites, what kind of web browser was used, et cetera. This is what’s called cross-site tracking and the cookie used by example-tracker.com is called a third-party cookie. In our testing we found popular websites with over 70 such trackers, all silently collecting data on users.\n In essence, cross-site tracking utilizes centralized tracking domains for scripts to communicate with from the sites the user actually visits. These tracking domains leverage third parties\u0026rsquo; access to browser storage (mainly cookies) to build profiles of all the sites the user has visited.\n Cross-site tracking   To continue the examples from the previous chapters, when the user's browser makes a request for image.imagestore.com while on the blog.ecommerce.cookiestatus.com website, the endpoint at image.imagestore.com will now know that the request originated from blog.ecommerce.cookiestatus.com, as this is included in the origin and referer [sic] headers.\nThus the endpoint at image.imagestore.com could now check if the user has an identifier cookie set on that domain, and they can augment the profile for that identifier with knowledge that the user has visited blog.ecommerce.cookiestatus.com.\nIf the user then visits another page on the internet that also communicates with image.imagestore.com, then that endpoint will be privy to yet another origin, and they can keep building the profile.\nThis is the essence of cross-site tracking - using a consolidated and centralized store (e.g. a cookie) to collect information from different domains.\nStorage access restriction Browsers\u0026rsquo; main weapon against cross-site tracking is restricting storage access. Because there are valid reasons for cross-site tracking (persisting user authentication, shopping baskets, consent status), tracking protection methods restrict storage access for third parties that have been identified and classified as compromising user privacy.\nThe Chrome browser is, for now, devoid of any significant tracking protection measures with regard to storage access. However, they have contributed to the discussion with their privacy sandbox initiative, as well as with upcoming features involving cookie restrictions and referrer policies.\nList-based protection Mozilla Firefox, for example, describes their own effort like this:\n In order to help give users the private web browsing experience they expect and deserve, Firefox will strip cookies and block storage access from third-party tracking content, based on lists of tracking domains by Disconnect.\n This approach of comparing the third-party domains against a curated list is utilized also by Microsoft Edge. Here's how they introduce Edge's tracking prevention:\n We’ve added a new component to Microsoft Edge, Trust Protection Lists**,** that contains the latest information on which organizations may be trying to track users on the web. This component allows us to be flexible with where we source details on what a tracker is and when we deliver updated lists to our users.\n The Brave browser, similarly, pulls in tracking domains from multiple sources. Notably, Brave combines prescribed lists (from e.g. EasyList and uBlock Origin) with a more dynamic list based on crawl data (PageGraph).\nWith list-based protection, the browser maintains a list of domains against which each outgoing HTTP request from the site is pattern-matched. If there is a match between the request target and one of the domains in these lists, the request is blocked.\nThis means that browsers can block both downloading script resources and HTTP requests to tracking endpoints (e.g. image pixels).\nBy blocking the script download, browsers don't need to worry about further storage access restrictions, because the JavaScript from the vendor was never loaded and thus can't abuse the browser storage on the user's company.\nBy blocking the pixel and other HTTP endpoints, browsers ensure that in cases where the site is loading the JavaScript from a non-blocked source, the script will not be able to communicate with its endpoint.\nThe biggest problems with list-based protection are:\n The performance overhead of pattern-matching each HTTP request against an ever-growing list of domains (something that these browsers are actively optimizing). Reaction lag to new trackers and domains that need to be blacklisted. Difficulty in handling locally cached and/or proxied requests. Harm to other functionality (besides tracking) that these blocked libraries provide.  Algorithmic protection The Safari browser has opted for a different tact. Instead of a binary approach (blocked vs. not blocked) and a set list of domains, Safari's Intelligent Tracking Prevention uses multiple methods to restrict the storage access for third parties that are algorithmically classified as having cross-site tracking capabilities. Here's how they describe the classification process:\n A machine learning model is used to classify which top privately-controlled domains have the ability to track the user cross-site, based on the collected statistics. Out of the various statistics collected, three vectors turned out to have strong signal for classification based on current tracking practices: subresource under number of unique domains, sub frame under number of unique domains, and number of unique domains redirected to. All data collection and classification happens on-device.\n However, Safari's approach is binary in a sense - you can either enable all cross-site tracking or none.\n Safari privacy settings   The algorithmic approach is effective because it identifies potential tracking domains dynamically and without using a centralized list. This means that there's less overhead in pattern-matching the HTTP requests as the list of domains for the browser would only include those the browser has actually communicated with.\nThe algorithm also ensures that locally hosted tracking domains and reverse proxies would also be under scrutiny (unless served in a same-site context).\nThe main problems with this approach are:\n False positives, where ITP classifies domains that serve no cross-site tracking purpose. There is also some reaction lag, because ITP would require enough data to run the algorithm. It's thus possible some communication with a tracking domain would be permitted before ITP restricts access. Lack of predictability, which is not necessarily a problem or a bad thing, but a list-based approach allows for community oversight of the domains that have been blacklisted. Since the ITP algorithm is not prescriptive, only the algorithm itself can be scrutinized, not its end result.  Note that for false positives blocking access to cross-origin storage, ITP offers the Storage Access API. However, there is no provision in ITP to remove a domain from the list of classified domains, which means that first-party protections would still apply.\n "
},
{
	"uri": "https://www.cookiestatus.com/introduction/summary-of-exploits/",
	"title": "Summary of exploits",
	"tags": [],
	"description": "",
	"content": "TABLE OF CONTENTS  There are a number of ways in which data exploitation is attempted by malicious trackers. On this page, these will be listed superficially.\nThe problem is that all these methods also serve valid and benign use cases, which means that when browsers seek to prevent these, they also end up preventing non-malicious and non-exploitative use of browser storage.\nAnd this is the nature of the beast. The very same APIs and methodologies that are used, for example, to improve the user experience of the site are simultaneously being repurposed by third parties for data collection and manipulation.\nSee the chapter on Impact for more details on how countering these exploits is impacting other, potentially benign use cases.\nThe exploits listed here are:\n Cookies in third-party context Link decoration Referrer decoration Fingerprinting CNAME records  Cookies in third-party context Leveraging browser cookies in third-party context (so-called third-party cookies) is the age-old way how advertising technology vendors build audiences for improving their targeting mechanisms.\nBy observing the user's browsing behavior across the web, ad tech vendors can build robust profiles and deduce the user's interest and affinity groups based on the sites they visit. Naturally, the robustness of this profiling depends on how many sites are included in this network, which is why large technology companies have the upper hand due to an extended reach and an established ecosystem.\nThese vendors are able to build these audiences if the user's browser does not block access to third-party cookies.\nFor example, if you browse a site that has a Google DoubleClick pixel firing, or has Google Analytics set up so that the site communicates with DoubleClick servers, you might see the following network request:\n Request to DoubleClick on the first site   It's a request to DoubleClick's domain (the request URL is something like https://1234567.fls.doubleclick.net/activityi...). As you can see in the cookie header, the user's browser has cookies set on this domain, and one of these cookies is named DSID with a long, hashed identifier string.\nNow, visit another, completely different site that also sends requests to DoubleClick servers and observe the network requests:\n Request to DoubleClick on the second site   It's another request to DoubleClick. This time the subdomain might be different, e.g. https://98765432.fls.doubleclick.net/activityi..., but since the cookie is written on the eTLD+1, you can see the result in the screenshot:\nThe DSID value is exactly the same as on the other website.\nThus, when you visit these two sites without restricting access to third-party cookies, DoubleClick will know that your particular DSID is now associated with visits to these two websites.\nThis type of covert tracking is called cross-site tracking, and it can be used by vendors to build their own profiles. However, it can also be abused by data management platforms (DMPs) that participate in cookie matching between multiple vendors to build an even larger user database.\n Unfortunately, this very same method is used for benign scenarios, such as persisting user authentication across different websites of the same organization.\nIf cookies in third-party context are blocked by the browser, then there are other means to achieve the same type of profiling, such as by repurposing the first-party context.\nLink decoration When vendors find out that their attempts to leverage cookies in third-party context are thwarted, they will repurpose the first-party context to continue tracking users across websites.\nFor example, if the vendor has a first-party ecosystem (such as a social media platform or a suite of products behind a shared authentication) coupled with an ad tech network (or they participate in cookie matching), they are well positioned to hijack first-party storage to build a profile of visitors.\nRepurposing first-party context is more effective if the vendor has a first-party service to which the user can log in. Services that only exist in third-party contexts (such as display networks) are most vulnerable to tracking protection measures.\n When the user is logged in to the vendor platform, they have a unique identifier that the vendor can use to recognize them. There is nothing exceptional about this - it's exactly how any login would authenticate a user.\nHowever, what the vendor can then do is decorate every single link leading out of the platform with a hash containing the user's unique identifier. Thus a link like https://www.cookiestatus.com/ now becomes https://www.cookiestatus.com/?vendorid=ABCDefgh1234IJKL5678mnop.\nWhen the user follows the link, all it takes is for any one of the vendor's JavaScript libraries (or a collaborating partner's JavaScript libraries) to run on the site for the ID to be written into first-party storage as a cookie, thus being impervious to third-party context blocking, and to be sent with e.g. remarketing or conversion pixel requests back to the vendor.\n URL decoration by vendors   This way the vendor will know that the logged-in user not only followed the link, because they can track clicks on the link, but they'll also know what they did on the target site due to the JavaScript firing on that site and communicating this information back to the vendor.\nLink decoration is not always reliable. Sites might introduce redirects that strip parameters from the URL (or break if non-whitelisted parameters are added), and tracking protection mechanisms (especially ITP) can be used to handicap first-party storage when link decoration is involved. Thus vendor platforms can also decorate the referrer string to avoid having their identifiers paraded in the URL of the target site.\nReferrer decoration Referrer decoration works exactly the same as link decoration, except instead of decorating the URL to which the user is navigated, the service creates an intermediate page through which the user is redirected.\nThis page would have the user identifier in its URL.\nBy doing so, the document.referrer string (and the referer HTTP header) would include the identifier, and the vendor's JavaScript libraries could, again, use this information to relay the user's navigation patterns back to the vendor.\nReferrer decoration is resilient to things like redirects stripping out query parameters of the target URL, but due to browsers\u0026rsquo; referrer policies, it is not a very reliable way to pass information from one site to the other.\n Browsers are taking a stronger stance against leaking information in referrers, adopting policies like strict-origin-when-cross-origin by default (this would strip referrer strings to their hostnames when the request is not same-site). Safari's intelligent tracking prevention is going even further, stripping document.referrer to eTLD+1 (so https://my.site.com/?id=12345 would become https://site.com) in cross-site tracking scenarios.\nIf the vendor does not have a strong enough first-party ecosystem to decorate links or referrers with user identifiers, they can attempt cross-site tracking through browser and device fingerprinting.\nFingerprinting Fingerprinting is a methodology where user's browser and device settings, at least those that are exposed to JavaScript APIs and HTTP headers, are used to build a digital fingerprint of the user's browser instance.\nThe logic is that since the user is very likely to use the same browser and device when browsing the web, this fingerprint can be utilized on different websites to uniquely identify the user.\nIndividual flags in the fingerprint (such as browser name, version, timezone) are not capable of recognizing a user, but the more flags that are added the higher the entropy, and the more likely the user can be uniquely identified by the combination of these browser settings.\nFingerprint APIs that utilize hardware configurations, such as Canvas, Web Audio, and WebGL are most robust, especially when used together. These are also the APIs most targeted by fingerprinting prevention measures.\n You can use the AmIUnique service to check how unique your current fingerprint is.\n Sample AmIUnique result   Browsers are coming down strongly on fingerprinting. Chrome introduced the privacy budget as a concept they're looking into, Safari is actively reducing potential fingerprinting surfaces, Firefox is blocking scripts that distribute fingerprinting tools (as is Edge), and then there are browsers like Brave where fingerprinting protections are front-and-center of development.\nCNAME records Sometimes the web browser is just too unreliable for vendors to leverage efficiently for their cross-site tracking purposes.\nAll the exploits listed above have native preventions in place in many browsers, and there are also browser extensions that help with tracking protection as well.\nThis is why some vendors recommend site owners to set up new domains in their own domain namespace (thus becoming part of first-party context), but instead of pointing to a server owned by the site, the domains would be mapped to vendor servers.\nA simple way to accomplish this is with a CNAME (canonical name) DNS record. The CNAME record maps a hostname such as tracker.domain.com to a web server endpoint, which can be provided by the vendor.\nThe website can then make requests to tracker.domain.com, and the web server at the end of this domain name would have access to all cookies written on tracker.domain.com and domain.com.\n CNAME record in DNS settings   It doesn't solve cross-site tracking by itself, because the endpoint would only have access to cookies written on domain.com (and not, e.g. vendor.com), but by sending the identifiers from link decoration or referrer decoration, or by fingerprinting the browser, the vendor can continue profiling the user with little risk of getting the domain blacklisted.\nBrowsers can't natively resolve CNAME records for a given hostname (apart from Firefox, to some extent). However, identifying known trackers in CNAME records is getting more attention, and it is likely that browsers will introduce the necessary APIs so that they can block or restrict this type of data access as well.\n"
},
{
	"uri": "https://www.cookiestatus.com/safari/intelligent-tracking-prevention/",
	"title": "Intelligent Tracking Prevention (ITP)",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/firefox/enhanced-tracking-protection/",
	"title": "Enhanced Tracking Protection (ETP)",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/edge/tracking-prevention/",
	"title": "Tracking Prevention",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/chrome/privacy-sandbox/",
	"title": "Privacy Sandbox",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/brave/shields/",
	"title": "Shields",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/introduction/impact/",
	"title": "Impact",
	"tags": [],
	"description": "",
	"content": "TABLE OF CONTENTS  The tracking protection measures taken by browsers have a widespread impact on a variety of things, including web development, advertising and marketing technologies, digital analytics, and user experience optimization.\nWebsites use cookies and other browser storage for a plethora of things, such as persisting login state, preserving items in a shopping cart, and for presenting tailored experiences in a first-party context, based on what the user has done while visiting the site.\nSimilarly, digital analytics uses anonymous/pseudonymous identifiers stored in first-party cookies to identify the hits collected across a span of time as coming from the same browser instance.\nThe methods used for cross-site tracking are often indistinguishable from those harnessed for more mundane purposes. Thus tracking protection measures tend to disrupt regular functionality of the web while seeking to eradicate malicious tracking.\nWeb development Websites regularly utilize cookies in both first-party and third-party context for persisting user authentication, for storing marketing consent, for identifying active sessions, and for operating with \u0026lt;iframe\u0026gt; elements that embed content from other sites.\nCookies in third-party context Because browsers like Edge and Firefox use lists (Trust Protection Lists and Disconnect.me, respectively) to collect information about known trackers, it's unlikely that any regular website would get their domain blacklisted. It would require that domain to participate in a tracking scheme, and for some public push to get the domain classified as a tracking domain.\n Beginning of the Disconnect.me entity list   On browsers like these, using their default tracking protection settings, websites could still continue to operate efficiently with third-party cookies.\nHowever, Safari, in introducing Intelligent Tracking Prevention, can block cookies in a third-party context for domains that don't actually participate in cross-site tracking. Since Safari algorithmically classifies domains on a browser-by-browser basis, it's entirely possible that a regular domain owned by the organization would get classified and thus have its cookies blocked when accessed in a third-party context.\nSafari describes the classifier like this: Out of the various statistics collected, three vectors turned out to have strong signal for classification based on current tracking practices: subresource under number of unique domains, sub frame under number of unique domains, and number of unique domains redirected to.\n Because of this, websites that require third-party cookies should utilize the Storage Access API to get user's consent to access first-party storage for a classified domain.\n Requesting storage access via the API   Cookies in first-party context With browsers such as Chrome, Edge, and Firefox, the first-party context is unimpacted when it comes to tracking protection.\nWith Safari, script-writable storage is impacted by Intelligent Tracking Prevention.\n Cookies set with JavaScript (document.cookie) have a maximum expiration of 7 days or 24 hours, depending on where the user navigated from to the current page. Other script-writable storage is restricted to 7 days in similar navigational scenarios.  This means that websites should avoid setting cookies with JavaScript where possible, and they should similarly avoid leveraging other script-writable storage for long-term persistence.\nCookies should never be used to store or send confidential information. They are inherently insecure, regardless of what flags are set when they are created.\n Websites should set business-critical cookies with the Set-Cookie header using the SameSite and Secure flags. If the cookie does not need to be accessed by JavaScript, then the HttpOnly flag should be set as well.\nBy setting the cookie in an HTTP response, it is unimpacted by Intelligent Tracking Prevention's restrictions on first-party storage.\nReferrer downgrade With cross-origin requests, browsers are moving to a stricter default policy of stripping the referrer to its origin, thus removing all path, query, and fragment identifiers from it.\nSafari is taking an even stricter stance, stripping all cross-origin referrers to their origin, but also downgrading referrers to eTLD+1 (so www.mysite.com/path becomes mysite.com) when the navigation source is a classified domain with URL decoration.\n Navigation from www.gtmtools.com (a classified domain) becomes a referrer string that\u0026#39;s stripped to eTLD\u0026#43;1   Because of the unreliability of the referrer, websites should avoid placing too much importance on interpreting what is stored in the referrer string, especially when using JavaScript's document.referrer.\n The Brave browser has adopted an even stricter stance, where they opt to spoof the referrer on cross-origin requests:\n Second, Brave modifies the referrer header when making cross origin requests. Brave \u0026ldquo;lies\u0026rdquo; on these requests, and says the request was being issued from the same domain being requested, instead of the true, cross-domain origin.\n Advertising and marketing technologies For AdTech vendors relying on storage access in third-party context, there are some tough times ahead. With Safari, Edge, and Firefox blocking third-party cookies for known trackers, it doesn't take much for a vendor to be blacklisted or classified as a tracker, leading to severely handicapped tracking capabilities.\nVendors are becoming more outspoken in their attempts to work around browser restrictions. Some companies are approaching site owners with instructions on how to setup CNAME redirects and reverse proxies to avoid ad blockers from preventing data collection. The ethical nature of such approaches is questionable at best.\nEven advertising that takes place in a first-party context (such as Google's search ads) is being hampered by browsers\u0026rsquo; efforts. Safari's Intelligent Tracking Prevention reduces the maximum expiration for cookies and browser storage if the user navigates to the site from an ad click, and if the source of the navigation is a known tracker (e.g. Facebook or Google). Thus the site's capability to attribute a conversion taking place in the near future to the ad click is compromised.\nIn short, for vendors requiring browser storage access in third-party context, these broad impacts can be observed:\n Ability to build graphs and profiles of users is restricted. Ability to target ads based on graphs and profiles of users is restricted. Ability to manage ad frequency is restricted. Ability to model attribution for view-through conversions is restricted. Ability to participate in cookie matching is restricted. Ability to provide demographics and interest data for analytics systems is restricted.  For vendors needing browser storage access in first-party context, these handicaps are in place:\n Ability to attribute conversions to ad clicks is somewhat restricted. Ability to measure efficiency of advertising is somewhat restricted. Ability to look back beyond the last touch in attribution models is somewhat restricted.  \u0026ldquo;Somewhat restricted\u0026rdquo; above refers to the fact that out of the major browsers, only Safari is currently restricting first-party storage access. Thus the severity of these restrictions depends on the typical share of Safari traffic on the advertised website.\n Digital analytics Digital analytics is an industry that measures, among other things, the effectiveness and return on investment of advertising.\nThere are analytics ventures that rely on cross-site tracking to analyze how uses are navigating across the websites of the internet, though much of this analytics is often done in addition to the primary focus of targeted advertising.\nHowever, there is an industry of first-party analytics, where the focus is on users who browse the website (or websites) of the organization, providing data and information about user behavior. This data can then be used to improve the user experience of the site, to build more effective campaigns, and to attribute conversions to different channels.\n Google Analytics is the most popular web analytics platform in use   On Chrome, Firefox, and Edge, the capabilities of digital analytics are not really restricted. Because much of digital analytics works with browser storage in first-party context, the restrictions on known trackers in third-party context do not impact the capability to monitor users browsing the website itself.\nHowever, on Safari, especially since ITP 2.1, the accuracy of first-party analytics has been compromised as well.\nWeb analytics tools such as Google Analytics drop a first-party cookie when the user first visits a website. This cookie is typically given a long expiration, such as two years, and the cookie expiration is reset each time a Google Analytics script runs on the page.\nThe cookie value is random and unique - by default Google Analytics uses a random number and the timestamp of when the cookie was set (e.g. GA1.2.123456789.1575363021), but sometimes the identifier is just a UUID.\nGoogle Analytics uses this cookie to identify that the separate hits coming from a user's browser belong, in fact, to the same browser.\n ITP impact on first-party analytics   Because this cookie is set with JavaScript, Safari's ITP restricts its expiration to the maximum of 7 days. This means that as long as the user visits the site with fewer than 7 days between each visit (and don't flush cookies for any other reason), they would be considered the same user. But if the visit frequency ever goes past 7 days, the user's cookie is reset and they would be considered a \u0026ldquo;New user\u0026rdquo; by the analytics tool.\nWith ITP 2.2, cookie expiration is reduced to 1 day if the user followed a decorated link from a known tracker (e.g. a Google ad click), making it even more difficult to analyze user behavior past a very short time window.\n Websites can move these identifier cookies to HTTP responses rather than have them be set with JavaScript. For now, this would preserve the expiraton of such cookies.\nReferrer downgrade impacts web analytics as well, because these platforms often provide channel data based on campaign identifiers in the URL and/or information stored in the referrer string. By downgrading referrers to their origins, web analytics tools can no longer accurately measure which particular page brought the user to the current site.\nUser experience optimization Here, user experience optimization covers the broad topics of conversion (rate) optimization and content personalization. The purpose of such efforts is to dynamically alter what the user might see on a website, based on random distribution to different variants, or based on targeting algorithms that choose the most suitable variant or content for the user.\nFor experimentation and data collection, it's important that the user's experience on the site be consistent. Being exposed to a different variant of the site with every page load can lead to confusion and introduce friction, especially in ecommerce contexts.\n Storage specification on the Optimizely platform https://bit.ly/2YdKmVG   To ensure consistency, optimization platforms set identifiers in the user's browser storage that tells these platforms which experimentation variant or personalization group they belong to. This storage would typically be accessed in a first-party context, but if the optimization derives targeting parameters from a global profile, the storage access might be required in a third-party context, too.\nBecause the vendors often provide their solutions using global content delivery networks (CDN), these domains tend to get blacklisted in browsers\u0026rsquo; tracking protection lists and algorithms. Thus their capability to deliver experiences based on data harvested from third-party storage is compromised.\nSimilar to digital analytics, first-party storage for content optimization is also restricted on Safari. Due to the short expiration time of script-writable storage, experimentation and personalization platforms can't deliver consistent experiences. In addition to this, the inability to control the sample sizes and deduplicate conversions often leads to too much noise in the calculation of statistical significance for the experimentation variations.\nOptimization platforms and websites running them should look into utilizing HTTP headers for getting and setting these cookies and for determining which content to show to the user, rather than the JavaScript APIs that have been compromised by Safari's ITP.\n"
},
{
	"uri": "https://www.cookiestatus.com/safari/useful-resources/",
	"title": "Useful resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/firefox/useful-resources/",
	"title": "Useful resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/edge/useful-resources/",
	"title": "Useful resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/brave/useful-resources/",
	"title": "Useful resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/chrome/useful-resources/",
	"title": "Useful resources",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/chrome/",
	"title": "Chrome",
	"tags": [],
	"description": "",
	"content": "Current status The Chrome browser doesn't currently have mechanisms designed specifically for tracking protection.\nClassification of \u0026ldquo;known trackers\u0026rdquo; Third-party cookies First-party cookies Other third-party storage Other first-party storage Referrer "
},
{
	"uri": "https://www.cookiestatus.com/edge/",
	"title": "Edge",
	"tags": [],
	"description": "",
	"content": "Current status    Detail Description     Mechanism Tracking prevention   Originally deployed in 78.0.276.8   Latest update deployed in -   User controls -    Classification of \u0026ldquo;known trackers\u0026rdquo; Third-party cookies First-party cookies Other third-party storage Other first-party storage Referrer "
},
{
	"uri": "https://www.cookiestatus.com/firefox/",
	"title": "Firefox",
	"tags": [],
	"description": "",
	"content": "Current status    Detail Description     Mechanism Enhanced Tracking Protection   Originally deployed in 69.0   Latest update deployed in 71.0   User controls -    Classification of \u0026ldquo;known trackers\u0026rdquo; Third-party cookies First-party cookies Other third-party storage Other first-party storage Referrer "
},
{
	"uri": "https://www.cookiestatus.com/safari/",
	"title": "Safari",
	"tags": [],
	"description": "",
	"content": "Current status    Detail Description     Mechanism Intelligent Tracking Prevention 2.3   Originally deployed in Safari 13 in iOS 13, macOS Catalina, Mojave, and High Sierra   Latest update Documented 10 Dec 2019   Latest update deployed in iOS and iPadOS 13.3, and Safari 13.0.3 on macOS Catalina, Mojave, and High Sierra   User controls ITP doesn't let users control how it works. Users can simply toggle ITP off by unchecking \u0026ldquo;Prevent cross-site tracking\u0026rdquo; in Safari's Security preferences.    Intelligent Tracking Prevention is the tracking protection mechanism used in the Safari browser, running on the WebKit browser engine.\nITP is unique in that it has a purely algorithmic approach to classifying domains that have the potential for cross-site tracking.\nDue to how ITP impacts both third-party storage access and first-party storage access, and due to Safari's market share especially in mobile devices, ITP can be considered a big disruption on AdTech and other industries that rely on data collection from browser users.\nNote that even though ITP is deployed in WebKit, other browsers that run on WebKit (e.g. Chrome on iOS) do not have ITP toggled on.\n ITP offers an ITP Debug Mode in Safari, which logs debug messages about the domains ITP has classified, and the domains for which storage has been purged.\nClassification of \u0026ldquo;known trackers\u0026rdquo; Third-party cookies First-party cookies Other third-party storage Other first-party storage Referrer "
},
{
	"uri": "https://www.cookiestatus.com/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "TABLE OF CONTENTS  This is a glossary of terms used in the website.\nAdTech Term used to describe advertising technologies and the companies and vendors working in AdTech. Many AdTech vendors utilize cross-site tracking to exploit user data in browser storage.\n Analytics Industry, vendors, tools, platforms, and methodologies grouped together by the pursuit of empirical data for measuring things like web performance, user behavior and advertising efforts.\nOften focuses on data collection in a first-party context, but especially in AdTech, analytics tools are used for collecting and analyzing data in third-party context as well.\n Chromium An open-source web browser project, used as the foundation of a variety of browsers (e.g. Brave and Edge (Beta)).\nMuch of the technology in Chromium is also used in the Chrome browser, but the two projects diverge when it comes to the full tech stack.\n Conversion An event or metadata of a user, collected by analytics tools and AdTech platforms to calculate the efficiency of campaigns and of content optimization and personalization efforts.\nEach organization can have their own interpretation of what a conversion is, but typically it is something that has a measurable impact on the business bottom line.\n Cookie A key-value pair (e.g. userStatus=logged-in) stored in the user's computer. Cookies are keyed to the domain on which they were set. Accessing cookies in same-site requests occurs in first-party context, and such cookies are termed first-party cookies. Cross-origin access happens in third-party context and these cookies are called third-party cookies.\n Cookie matching / syncing Data management platforms (DMP) and demand-side platforms (DSP) can exchange user information in their own data stores, mapping each platform's own list of users to other lists by utilizing shared keys in third-party storage.\nThis way a DMP can build a comprehensive graph of a user's cross-site navigation on the web without actually having their own data collection architecture present on all the websites.\n Cross-site tracking Cross-site tracking refers to a tracking domain harvesting data from user's navigation and actions on other, unrelated domains. This is typically done by storing an identifier in a cookie on the tracking domain, and communicating with the tracking domain in a third-party context.\nCross-site tracking happens covertly, and the user typically has no knowledge of all the data that has been collected from them while browsing the web.\n Domain hierarchy Domain (or DNS) hierarchy refers to the domain names in a given domain name string (fully qualified domain name). With the document.cookie JavaScript API, the browser can read and write cookies on the current domain and all the domains higher in the hierarchy, all the way to eTLD+1.\nThus a user browsing a site on sub.blog.domain.com can read and write cookies on sub.blog.domain.com, blog.domain.com and domain.com.\n Enhanced Tracking Protection (ETP) The name of the tracking protection mechanism in the Firefox web browser.\nETP uses the Disconnect.me lists to determine whether a given domain is a known tracker or not.\n eTLD+1 Effective top-level domain plus one part. eTLD would comprise the top-level domain (e.g. .com and .uk) and sometimes a second-level of hierarchy (e.g. .co in .co.uk or .com in .com.au). Thus eTLD is the same thing as the Public Suffix.\nThe \u0026ldquo;one part\u0026rdquo; is then the next level in the domain hierarchy, i.e. the domain name the site would have acquired to map to their servers.\nThe eTLD+1 term is used in particular by Safari's Intelligent Tracking Prevention documentation to refer to the highest domain name the browser has read/write storage access to.\n First-party In the context of storage access, first-party references the domain the user is currently on. Browser storage is typically completely restricted to the first-party.\nCookie access is a bit different, as the browser can access cookies in a first-party context on the domain they are on and on any domain higher up in the domain hierarchy (all the way to eTLD+1).\n Intelligent Tracking Prevention (ITP) The name of the Safari browser's tracking protection mechanism and related tools.\nDue to its wide-spread use (especially on mobile devices), its algorithmic evaluation of tracking domains, and its impact on first-party storage, ITP has been a big disruption on AdTech and analytics industries.\n Link decoration The act of adding URL query string parameters (e.g. https://www.domain.com?id=12345 or hash fragments (e.g. https://www.domain.com/#id=12345) to outbound links from a website with the purpose of passing some key-value pairs from first-party storage to another site without having to worry about third-party storage access restrictions.\nSince the values are passed in the URL, the target site can access them by simply taking them from the URL string.\n PageGraph PageGraph is a tool built for the Brave browser, which analyzes the way in which a web document operates (and is operated on) within the browser.\nPageGraph builds a representation of things like node changes, network requests, and script execution, so that this research could be used to, for example, optimize the privacy-preserving feature restrictions of the browser that produced the graph.\n Quantum The browser engine used by the latest versions of the Firefox browser. It's an improved / redesigned iteration of Firefox's original Gecko engine.\n Referrer When the web browser issues a request to a web server, that request often includes the referer  [sic] header to indicate the URL the request originated from.\nIf the target resource is a web page, i.e. the request originated from a link click, when the web page is rendered the referrer string is written into the document.referrer property.\nDue to its capability to carry information that could be utilized in cross-site tracking contexts, browsers are actively working towards making the referrer string less informative by a process called referrer downgrade or by completely stripping and/or spoofing it.\n Referrer downgrade Downgrading the referrer means stripping out parts of it that could be utilized for cross-site tracking or carrying sensitive information.\nBrowsers are working on defaulting to strict-origin-when-cross-origin, which would mean that for request outside the current domain namespace the referrer would be stripped of its path, query, and fragment parts. Thus https://www.sourcedomain.com/some-page-with-link/?id=12345 would become https://www.sourcedomain.com in the referer header.\nThe Brave browser strips the referrer in all navigational cross-origin requests (e.g. clicking on a link to move to another page). For other cross-origin requests, the referrer header is spoofed to contain the origin being requested rather than the origin being referred from.\n Script-writable storage Refers to browser storage that can be accessed with JavaScript. Typically this would be browser cookies, localStorage, sessionStorage, and IndexedDB.\n Third-party In the context of storage access, third-party means that the browser is trying to access storage that is not on the current domain.\nFor example, while on web.domain.com if the browser makes a request for an image on image.imagestore.com, the request would have access to cookies written on image.imagestore.com only if the browser did not block third-party cookies. Similarly, if the response from image.imagestore.com tries to write a cookie with a Set-Cookie header, this would only work if the browser allowed third-party cookies.\nIf the web browser loaded another domain's content in an \u0026lt;iframe\u0026gt; element, then any storage access (using e.g. document.cookie or localStorage) within that \u0026lt;iframe\u0026gt; would happen in a third-party context.\n WebKit A browser engine developed by Apple and used as the engine for the Safari browser and all the iOS browsers.\n"
},
{
	"uri": "https://www.cookiestatus.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.cookiestatus.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]